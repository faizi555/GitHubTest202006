此为阅读廖雪峰老师官网教程加上自己理解的产物-。-！


数据库通过数据结构管理数据，数据库模型分三种
	1.层次模型：此模型像分支树一样的树状模型。
	2.网状模型：和层次类似，只不过形状非树，更像网多一些。
	3.关系模型：关系模型和二位模型简直一模一样！数据通过行号+列号进行唯一确认，看起来像excel表格。
	现在最广泛使用的就是关系模型。
			
	数据类型：INT		  （int）	    整型			4字节整数类型，范围约+/-21亿。
			  BIGINT	  （bigint）	长整型			8字节整数类型，范围约+/-922亿亿。
			  REAL		  （real）		浮点型			4字节浮点数，范围约+/-1038。
			  DOUBLE	  （double）	浮点型			8字节浮点数，范围约+/-10308。
			  DECIMAL(M,N)（decimal）	高精度小数		由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算。
			  CHAR(N)	  （char）		定长字符串		存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串。
			  VARCHAR(N)  （varchar）	变长字符串		存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串。
			  BOOLEAN	  （boolean）	布尔类型		存储True或者False。
			  DATE		  （date）		日期类型		存储日期，例如，2018-06-22。
			  TIME		  （time）		时间类型		存储时间，例如，12:20:59。
			  DATETIME    （datetime）	日期和时间类型	存储日期+时间，例如，2018-06-22 12:20:59。
	bigint满足整数存储，varchar满足字符串存储。数值类型的话尽量使用bigint长整型。
	real也可以写成float
	
	主流数据库关系分类：商用数据库，例如：Oracle，SQL Server，DB2等；
						开源数据库，例如：MySQL，PostgreSQL等；
						桌面数据库，以微软Access为代表，适合桌面应用程序使用；
						嵌入式数据库，以Sqlite为代表，适合手机应用和桌面程序。
						
	sql：不同数据库支持的扩展功能都不一样，简称为"方言"。
		 DDL：允许用户自定义数据，创建，删除，修改表结构等操作。一般DDL由数据库管理员执行，
		 DML：用户能对数据进行增删改操作，这也是数据库日常操作。
		 DQL：支持用户查询数据，最频繁的日常操作。
		 注：有些数据库分大小写，有语句忽略大小写，sql命令窗口模式的话结尾必须，必须，必须+;号。
	
	
	登入MySQL：如果用命令提示符下进入的话输入mysql -u root -p回车，root是用户名也可以改为其他用户
			   回车后输入密码即可，成功的话提示符变为mysql>。
			   如果使用mysql自带的命令提示符直接输入密码即可。
			   退出mysql输入exit，但是退出命令提示符后，mysql服务器还在运行。
			   注：mysql如果登陆失败，可能是服务没有启动，因为有些是服务手动开启的。
	
	
数据库关系模型：

	数据库表之间会存在一定关系，比如：
			一对多：一个老师（老师表）有多个学生（学生表）。
			多对一：多个学生（学生表）有一个老师（老师表），其实一对多和多对一就只是反过来而已。
			多对多：老师要管理多个班级（班级表），一个班级有多个老师（老师表）。
			多对多一般是通过两个一对多使用中间表进行关联，将teacher表的id和class表的id进行对应了。
			关系数据库的关系靠主外键进行维护，两个表使用主外键进行关系连接，有些企业开发为了提高效率不使用主外键。
			主键：表中每条数据的唯一标识（This is Sole）也就是不能重复也不能为null。主键是不能修改的，
				  选取主键的原则就是不使用任何与业务相关的字段作为主键，一般主键的类型如下：
						自增整数，数据库为每条记录添加自增整数，就不用担心主键重复。
						全局唯一GUID类型：如命全局唯一的字符串，如8f55d96b-8acc-4636-8cb8-76bf8abc2f57，
										  GUID算法通过网卡mac地址，时间戳和随机数生成保证不重复，很多语
										  言内置了GUID深渊发，可以自行预算出主键。
				  一张表可以有两个主键，称为联合主键，联合主键允许一列可重复，不是所有都重复即可（一般不使用此主键）。
		    外键：一张表通过字段把数据和另一张表进行关联，这种字段称为外键。
				  alter table 表名
				  add constraint 外键约束名
				  foreign key （外键名）
				  references 关联表名 （关联表主键）
				  上面语句的大概意思为：将表名的外键字段与关联表名的主键进行关联，约束名为外键约束名。
										外键约束名可以随意取名，由于外键约束会降低数据库性能，大部分互联网应用
										为追求速度，不设置外键约束，靠后期的程序保证逻辑正确性。
				  alter table 表名
				  drop foreign key 外键约束名 
				  以上为外键删除语句，靠外键约束名对外键进行删除。
				  将表分离成多个表是为了提高新能，根据需求进行查询。
				  
										  
	行，列：
			表的一行称为记录（Record），记录是一个逻辑意义上的数据。
			表的一列称为字段（Column），同一个表每一行记录都有相同的若干字段。
			字段定义了数据类型是否允许为null，若为null表示数据不存在，
			一个整型字段为null不代表值为0，
			一个字符串字段为null不代表值为空''。
			注：通常情况下字段避免为null，这样的话简化查询条件，加快查询速度，利于后期读取数据后无需判断是否为null。
			
	索引：数据库最重要的东西之一（用以优化查询速度）
		  通过索引数据库查询时不用扫描整个数据库，直接定位到符合条件的记录，大大加快查询速度。
		  alter table 表名
		  add index 索引名（列名）
		  上面语句的意思是：为表名下的列名添加索引，索引名为"索引名"。
		  一般是为唯一的但是又不能作为主键的列添加唯一索引如姓名或者身份证之类的。
		  一个表也能创建多个索引，优点是提高查询效率，缺点是增删改时需要同时修改索引，索引越多增删改就越慢。
		  数据库会自动为主键创建索引，主键索引效率是最高的，因为主键保证绝对唯一。
		  廖老师原话：索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。
					  反过来，如果记录的列存在大量相同的值，例如gender列，大约一半的记录值是M，另一半是F，
					  因此，对该列创建索引就没有意义。
		  唯一索引：alter table 表名
					add unique index 唯一索引名（列名）		通过unique创建唯一索引
					以上是创建唯一索引，保证索引唯一性。
					
					alter table 表名
					add constraint 唯一约束名 unique （列名）
					以上是只添加唯一约束不创建唯一索引。
					
		  不论是否创建索引，用户和程序使用数据库时没有任何区别，如果有索引时查询效率会提高，
		  如果没有索引查询也能正常执行，只是速度慢一点，索引可以在使用数据库时逐步优化。
		  
		  
增	inster into
删  delete
改  update
查	select
		  
		  
查询数据
	查询语句：select * from 表名;								最基本的查询语句，*代表全部，查询该表的所有数据。
			  select 列名1,列名2... from 表名;					也可以查询指定的列，又称作投影查询。
			  select * from 表名 where 条件表达式;				where是条件，比如只查询id为1的数据信息就是id=1。
			  select * from 表名 where 表达式1 and 表达式2;		使用and表示查询同时满足两个查询条件的数据信息，
																将and换成or就是两个表达式满足一个就行。
			  select * from students   
			  where 列名 between 2 and 5;						和上面的and语句是一样的，between是之间的意思，也就是说查询
																指定列名2到5之间的数据。
			  select * from 表名 where not 条件表达式；			not表示查询不符合表达式条件的数据，
																not id=1也可以写成id <> 1。
			  select * from 表名 where 列名 in （条件1,条件2）; in是只查询符合条件的数据。查询id输入1，5就只查询1和5。
			  select 1+1; 										select也可以用于查询运算结果。
			  
	排序：（order by）默认asc，升序，如果有where 语句就在其后使用。	  
			  select * from 表名 where order by 列名;			查询结果按照列名进行从低到高的升序排序。
			  select * from 表名 where order by 列名 desc;      在语句末尾加上desc对查询列名进行降序排序。
			  
	分组查询：（group by）对查询到的相同的数据进行分组。
			  select count(*) 别名... from 表名 group by 列;	查出列的总数并进行分组。比如为1的多少个，为2的多少个，以此类推。
	
	
	分页查询：（limit 每页显示数量 offset 下标（从0开始））查询时数据库数据过多可采用分页显示，指定每页显示数量。
			  select * from 表名 limit 每页显示数 offset 下标;  将表中数据进行分页展示，在其中输入每页显示数量和下标即可。
																在mysql中还可以简写为limit 每页显示数,下标。		
																在分页查询时下标越大查询效率越低。
	分页查询总页数：总数据量除以每页显示数量，向上取整。
	
	聚合查询：（使用聚合函数进行的查询）
			  select count（1） from students;					count函数是查询所有列的行数1也可以改为*，1比*的效率高。
																10条数据就显示10。
			  sum		该函数计算某列的总数，该列必须为数值类型，如果查询成绩的话就是算出所有学生的总成绩。
			  avg		该函数计算某列平均值，必须为数值类型，查询成绩的话就是算出所有学生的平均成绩。
			  max		计算某列的最大值，查询成绩的话就是查出成绩最高的学生。
			  min		计算某列最小值，查询成绩的话就是查出成绩最低的学生。
			  
			  以上函数可根据需求对count进行替换，也可用作条件查询需要的语句。
			  如果聚合函数查询where条件没有匹配的数据，count会返回0，sum、avg、max、min会返回null。
			  select ceiling(count(*) / 每页显示数量) from 表名;	通过聚合查询总页数。
			  
	多表查询：select * from 表1，表2....;		查询多张表的数据。
			  多表查询又称为笛卡尔查询，此查询由于结果是目标表的行数乘积，
			  对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，
			  对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。
			  两个表的每一行两两都拼在一起，
			  列数是查询表列数之和，行数是查询表行数之积。
			  可以通过对表名设置别名和增加查询条件减少乘积。
			  因为此查询方式有乘积，导致查询结果集数据量巨大，so不建议使用。
	
	连接查询：连接查询可以看作是笛卡尔的super版本，连接查询对多个表进行join运算，确定一个主表作为结果集，
			  将其他的表选择性的连接到主表结果集，join查询也可以配合where和order by等等进行使用。
			  内连接：（inner join）
					 select 1.xx,1.xx,2.xx,2.xx from 表名 1 inner join 表名 2 on 1.xx=2.xx;
					 外连接一般都是有主外键关系的表进行查询时所使用的。
					 可设置需要查询的列名，为表设置别名，使用表别名.列名，即区分不同表的列名。
					 inner join 是需要连接的表，on是条件，上面语句意思是1连接2，查询条件1=2的数据信息。
					 inner join内连接查询两张表都存在的数据才进行展示。
			  外连接：（outer join）
					 right outer join 右外连接
					 left outer join 左外连接
					 full outer join 完全外连接
					 外连接和内连接的区别是，内连接必须要两张表数据同时存在，比如有11班而且11班有学生，否则不显示数据。
											 外连接将显示所有查询出的数据。
					 right outer join返回右表都存在的行数据，左表不存在的数据用null表示。
					 left outer join返回左表都存在的行数据，右表不存在的数据用null表示。
					 full outer join的话将两张表数据全部查询展示出来，将对方不存在的列用null表示。
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
			
			
			
			
			
			
			
			
			
			
			
			




