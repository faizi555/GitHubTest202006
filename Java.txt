Math.random()*10;	生成随机数*10，就是生成10以内不包括10，从0开始。


JDK文件解析：
	java安装bin目录下有很多可执行文件。
	java：是jvm，运行java程序就是启动jvm，然后可以让jvm执行指定的编译后的代码。
	javac：是java编译器，用于将java源码文件(.java后缀的文件)编译为java字节码文件(.class结尾)。
	jar：用于将一组.class文件打包成一个.jar文件，便于发布。
	javadoc：用于从java源码中自动提取注释并生成文档。
	jdb：java调试器，用于开发阶段的运行调试。

使用cmd运行java文件：
	创建一个文本文件写个类，类名和文件名一致，文件后缀改为java。
	先用javac将java文件编译成class字节码文件，然后使用java命令执行字节码文件
	Hello.java  >>compile>>  Hello.class  >>execute>>  Run on JVM
	source code	   (编译)	   byte code	 (执行)
	(源码文件)				  (字节码文件)
	
	可执行文件javac是编译器，可执行文件java是虚拟机。
	在保存java文件下打开cmd窗口，
	javac Hello.java	编译java文件，将java编译成class
	java  Hello.class	执行class文件
	以上步骤是必须的，但是在java11后加入了新的功能，可以运行单个文件源码了！
	也就是说可以直接运行java了，不需要使用javac编译成class文件了。
	但是在实际项目中很少有不依赖第三方库的java源码，大多情况下无法直接运行java源码文件，因为它需要以来其他的库。
	定义类的时候可以不写public也能正常编译，但是此类无法从命令行执行。
	java入口规定方法必须是静态的，方法名必须为main，括号内参数必须是String数组。

常用注释：
	单行注释：//
	多行注释：/*开头    */结尾
	特殊多行：/**   	*/结尾，中间每行以*开头
	
	
注：代码是按顺序执行的！！！	
	
java規定：
	类名以大写开头，方法名小写开头驼峰规则。
	public为访问修饰符，static是修饰符。
	方法上加上DOTO是等待后续修改或编写的方法。

基本数据类型：
	整数类型：byte、short、int、long
	浮点类型：float、double
	字符类型：char
	布尔类型：boolean
	计算机内存最小储存单元是字节(byte)，一个字节是一个8位二进制数，即8个bit(位)。
	它的二进制表示范围从00000000~11111111，换算成十进制0~255，换算成十六进制是00~ff。
	(身为数学渣子的我，从廖老师网站搬过来的)
	
	内存单元从0开始编号，称为内存地址，每个内存单元可看作是一间房间，内存地址是门牌号。
	一个字节是1byte，1024字节是1k，1024k是1m，1024m是1g，1024g是1t，一个拥有4t内存的计算机字节数量：
	4T = 4 x 1024G；
	   = 4 x 1024 x 1024M；
	   = 4 x 1024 x 1024 x 1024K；
	   = 4 x 1024 x 1024 x 1024 x 1024；
	   = 4398046511104；
	
	不同数据类型占用的字节也不一样：
	byte   	1	  整型
	short  	2	  整型
	char   	2	  字符型
	float  	4	  浮点
	int	   	4	  整型
	long   	8	  整型
	double 	8	  布尔
	因为不了解数学，一下只做了解：
		java定义的带符号的整型。最高位的bit表示符号位(0位正，1为负)
		浮点类型是小数，因为小数点可以向前或向后浮动，所以称为浮点，对于float浮点类型数值后需加上f，如1.33f。
		布尔只有true和false两个值，数值比较运算也可替代true和false如：false1=1>2	true=1<2。
		char只能保存一个字符使用单引号''。
		String字符串引用类型使用双引号""。
		引用类型类似C语言的指针，内部存储一个地址，指向某个对象在内存中的位置涉及类和数据库(数据库学的细碎后面再说)。
		常量需要在变量前加上final修饰符，常量名通常全部大写，常量值是不能被改变的，枚举enum相似，只是枚举定义的是类。
	
	var关键字：有事类型名过长可将变量的类型写为var：var s = new Shool(); 效果等同于  shool s = new shool();
			   因为编译器会根据赋值语句自动推断变量的类型。
	变量存在作用域即作用范围，在同一个或同一个中的{}花括号中生效，如果超出范围，编译器会报错。
	
	整数运算：
		java的整数遵循四则运算规则，可以任意嵌套小括号，括号内优先运算。
			
		自增减：++n的话表示先加1再引用n，n++则相反是先引用再加1。
		移位运算二进制中，左移是乘2，右移是除2。
		位运算：
			&：相同为1，不同为0。
			|：任意为1，结果为1。
			~：0，1互换，输入0时结果为1，反之亦然。
			^：两个数值不同为1，否则为0。
		运算符优先级：
					()
					! ~ ++ --
					* / %
					+ -
					<< >> >>>
					&
					|
					+= -= *= /=
		
		注意++写在前面和后面计算结果是不同的，++n表示先加1再引用n，n++表示先引用n再加1。
		不建议把++运算混入到常规运算中，容易自己把自己搞懵了。(搬运廖老师的原话，谁做项目写++n，n++的钻简直牛角尖，虽然是因为我不会)。
		自动类型转换发生在字节低转为字节高。
		强制类型转换字节高转为字节低，但是字节高转为字节低时会损失精度，导致结果不准确。
	浮点数运算：
		浮点数只能做加减乘除运算，不能做位运算和移位运算。
		浮点数虽然范围大但是常常无法精准表示。
		0.1在计算机中无法精确表示，因为十进制0.1转成二进制时无限循环小数。
		如果小数强转为整数类型的话，小数.后的值会被舍弃如，12.3和12.7皆为12。
		整数和浮点进行运算的时候整数自动转为浮点类型。
	布尔运算：
		只有true和false	；
			比较运算符：>，>=，<，<=，==，!=
			与运算 &&
			或运算 ||
			非运算 !
		关系运算符的优先级从高到低依次是：
			!
			>，>=，<，<=
			==，!=
			&&
			||
		布尔里有一种短路运算：
			x1 && x1 如果x1为false时x2不再进行运算，第一个值为false时不再进行运算直接返回false。
			如果x1为true时，第二个值错误不能进行运算时，会报错，这样来说短路也相当于是一种保护机制。
		三元运算符：
			表达式：成功？失败
			意思是如果a>b的话，就显示：后的语句，如果a<b的话就显示？后的语句。
	字符和字符串：
		字符时基本数据类型，是charrcter的缩写，保存一个unicode字符。
		查看字符在unicode中的编码只需要将char赋值给int即可。
		字符串常见的转义字符：
			\" 表示字符"
			\' 表示字符'
			\\ 表示字符\
			\n 表示换行符
			\r 表示回车符
			\t 表示Tab
			\u#### 表示一个Unicode编码的字符
			可以使用+将多个""进行连接效果和一个""一样
			如果使用+连接字符串和其他数据类型会将其他数据类型自动转为字符串再进行连接。
		从java13开始使用"""...."""表示多行字符串和/*...*/效果差不多。
		而且字符串是不可变的，变的是指向：
			如果创建了两个s字符串
				String s = "aa";
				String s = "bb";
				会在内存中创建两个变量aa和bb，s只是一个指针的效果，s="aa";时候虚拟机创建了aa字符串，
				然后用变量s指向它，第二次s="bb";时虚拟机创建bb并且s指向它。
				当然如果a="aa";已经创建aa变量了，b="aa";时b也只是去内存中指定了aa而已，也就是说aa在内存中只创建了一次。
			null和""是有区别的，null是没有值，"是为空的有效字符串。
	数组：
		数组可以是值类型或引用类型，但是数组本身是引用类型。
		多个相同的数据类型可以使用数组进行保存。
		int [] name = new int[2]; 第二个[]中的数字为数组的个数，数组下标为0,并且规定几个必须创建几个。
		name[0] = 1;
		name[1] = 2;
		name.length使用此语法获取数组大小。
		name[1]查看下标为1的数据，输入几查看几。
		int [] name = new int [] {1,2,3,4}; 使用此方式不用指定数组大小，输入保存的数据编译器自动推算数组大小。
		int [] name = {1,2,3,4}; 这是最简洁的创建数组方式。
		
流程控制：
	System.out表示输出流	System.in表示输入流
	语句从上到下按顺序执行。
	输出语句：System.out.print();	输出后不换行。
			  System.out.println(); 输出后换行。
			  ecplise中输入sout和sys使用alt+/快捷键快速生成。
			  占位符	说明
				%d		格式化输出整数
				%x		格式化输出十六进制整数
				%f		格式化输出浮点数
				%e		格式化输出科学计数法表示的浮点数
				%s		格式化字符串
	输入：先创建Scanner对象。
		Scanner scanner = new Scanner(System.in);
		scanner.nextLine();		输入字符串
		scanner.nextInt();		输入整数
	
	switch语句：使用多重if判断的话，switch更加清晰。
		switch(){
		case 1:
			break;
		case 2:
			break;
		default:
		}
		如值=1就进入第一层，因为case具有穿透性，不写break的话，会将下一层也输出，如果下一层也没break，就滚雪球了。
		default是默认值，case的顺序不影响逻辑。
		switch条件值也可以是字符串或者枚举。
		从java12开始switch语句更加简洁化，使用模式匹配保证只有一条路径会被执行，并且不需要break。
		switch(标准值){
			case "条件值" -> 语句 ;
			case "条件值" -> 语句 ;
			case "条件值" -> {语句 };
			default ->	语句;
		}
		以上是java12后的语句，如果写逻辑判断等有多个语句的话可用{}进行扩盖，并且新语法使用->。
		可以将swithc的值作为变量进行设置int xx = switch(){}
		可以case"123","312"使用,设置多个条件。可以使用yield返回一个值作为返回值。
	while循环：根据条件做循环就按，条件满足时退出循环
		while(条件表达式){
			循环语句
			值++；
		}
		开始时先判断条件表达式，如果位true就运行，false就终止跳出while循环。
		while必须在最底层使用条件值++，否则无限循环
	do{
		语句;
		值++;
	}while(条件表达式);
	dowhile较while不同，
	while先判断再执行，dowhile先执行再判断。
	
	for循环：最便利的循环之一，在每次循环后更新计数器计数器通常为1不需要写n++。
		for(int i=0; i<=100; i++){
			i<=100是条件；
			i++;是自增；
			int i=0;声明一个计数器并指定默认值；
		}
		对计数器变量的修改尽量在for循环中。
	for each使用此循环遍历数组,也能遍历输出map，list等集合。
		int [] a={1,3,5,7,9};
		for(int b : a){
			 System.out.println(b);
		}
		
		for循环可以访问数组索引，for each直接迭代每个数组元素，无法获取索引。
		
		在while和for中都能使用break和comtinue语句(switch也能用)
		在循环中判断加上break，当数值到达xx时就break，
		注意break只挑出当前那层循环，如果有两层在最里层加上break，就是跳出里层循环，外层循环不会结束。
		comtinue提前结束本次循环，comtinue后的语句不执行，然后继续循环。
	
数组：Arrays.toString(数组名);快速打印数组内容
	  Arrays.sort(数组名);对数组进行排序，但实际上时修改了数组本身。
	冒泡排序的特点，每一轮循环结束后，最大的一位被交换到末尾，so下一轮就可以忽略最后的数，
	每一轮循环都比上一轮循环结束位置靠前一位。
	for(int i=0;i < ns.length - 1;i++){
		for(int j=0;j < ns.length-i-1;j++){
			if(ns[j] > ns[j+1]){
				int tmp = ns[j];
				ns[j] = ns[j+1];
				ns[j+1] = tmp;
			}
		}
    }这是冒泡排序的例子，降序只需要将if中的>换成<。
	还有二维数组：
		int[][] ns = {
            { 1, 2, 3, 4 },
            { 5, 6, 7, 8 },
            { 9, 10, 11, 12 }
        };酱紫的，二维数组要使用两个[][]，使用，隔开每个数组
		查看特定数组的某位数时ns[0][0]，意思是下标为0的数组中下标为0的数字。
		二维数组.length时显示的是二维数组的长度。
		ns[0].length查看下标为0数组的长度。
		Arrays.deepToString();能打印二位数组。
		还有一种三维数组，就是二维数组的数组。
		int[][][] ns = {
			{
				{1, 2, 3},
				{4, 5, 6},
				{7, 8, 9}
			},
			{
				{10, 11},
				{12, 13}
			},
			{
				{14, 15, 16},
				{17, 18}
			}
		};
	

命令行参数：
	程序入口时main方法，main方法可以接受一个命令行参数，它是String[]数组，此命令行由jvm接受用户输入传给main方法。


面向百度编程：
	class(类)
	instance(实例、类)
	method(方法)
	field(字段)
	面向过程编程：将模型分解成一步一步的过程，比如洗一个TODO任务：
					1.读取文件
					2.编写TODO
					3.保存文件
	面向对象编程：通过对象的方式，将现实世界映射到计算机模型的一种编程方式。
					基本概念：类、实例、方法。
					面向对象实现方式：继承、多态。
					java本身提供机制：package、classpath、jar。
					java标准库提供核心类：字符串、包装类型、javabean、枚举、常用工具类。
	
				类定义的是一种抽象的概念，如电脑是类，那么和电脑相关的实例都可放在其中。
				面向对象主要就是class(类)和instance(实例、对象)
				class是对象模板，定义如何创建实例，so，class本身就是一种数据类型。
				instance是对象实例，instance是根据class1创建的实例，可以创建多个instance，每个instance类型相同，但属性可能不同。
				
				将一组数据汇聚到对象上就是数据封装。
				Student s = new Student();
				创建了一个实例，通过变量s指向它，Studnet s是创建student的变量s，new Student()是创建实例。
				有了这个实例就能通过变量操作实例，s.字段。来使用studnet中封装的字段。
				如果实例类型一样，变量名不一样那么在调用字段的时候在内存中有独立的空间，互不干扰。
				指向instance的变量都是引用变量。
	方法：一个class可以含多个field，如果field使用public修饰暴露给外部会破坏封装性。
			可以使用private进行修饰拒绝外部访问，private是私密的，public是公用的。
			使用private的话，可用get、set方法让外部获取字段，外部用过调用get方法获取字段，set方法修改字段。
			也可以在set中加上判断，对输入值进行判断是否符合条件使输入值更加严谨。
		定义方法语句：
			修饰符 方法返回类型 方法名(方法参数列表) {
				若干方法语句;
				return 方法返回值;
			}	没有特定情况下可省略return。
			可以在其中的方法封装一个类的对外接口，调用方不需要也不用关心实例的方法中做了什么操作。
			
		在方法中可使用一个隐含变量this，它始终指向当前实例，so，通过this.field就能访问当前所在实例的字段。
		若没有命名冲突就可省略this，如歌有局部变量和字段冲突，那么局部变量优先级更高，必须加上this。
		
		方法参数：
			方法可以报包含多个参数，方法参数用于接收传递给方法的变量值，调用方法时，必须严格按照参数设定的定义传递。
		
		可变参数：
			相当于数组类型public void setNames(String... names) ，那么调用的时候就可以写成，
			g.setNames("Xiao Ming", "Xiao Hong", "Xiao Jun")。
			所以完全可以将可变参数改为数组类型。
			
		参数绑定：
			调用方将参数传递给实例方法时，调用传递值会按照参数位置进行绑定。
			基本参数类型传递，调用方法值的复制，双方各自的后续修改互不影响。
			但引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一对象，
			双方任意一方对此对象的修改都会影响对方(因为指向的同一对象)。
			
	构造方法：
		在创建实例的时候就将内部字段全部初始化为合适的值。
		创建类的时候，默认创建一个隐式的类的构造方法，默认的构造方法是无参的没有返回值的。
		如果自定义一个构造方法那么编译器就不再创建默认构造方法，这个时候我们就要自己创建无参构造。
		因为如果你自定义有参构造，那么实例化对象的时候构造方法中没有参数就会报错。
		没有在构造方法中初始化字段时，应用类型字段默认null，int默认0，布尔默认false。
		可以设置多个不同参数的构造方法来对应不同的参数需求。
		一个构造方法可调用另一个构造方法，使用this()；
	
	
	继承(extends)：
		java中只允许单继承，但是可以无限单继承，a继承b继承c继承d.....依次类推。、
		java中创建的类会默认继承object类，object是没有父类的。
		b类继承另a类的时候，b能使用a类的方法和属性，增加程序扩展性，使用extends实现继承。
		b继承a时，b就拥有了a的所有功能，也能为b添加独有的功能。
		术语中被继承的类被称为：
			超类(super class)
			父类(parent class)
			基类(base class)
		继承的类又称为：
			子类(subclass)
			扩展类(extended class)
		但是子类中不能有和符类相同的字段。
		继承的特点是子类无法访问符类的private字段或private的方法。这样的话继承的作用就被削弱了。
		这样的话，就需要将private改为protected，被protected修饰的字段或方法可以被子类访问。
		
		如果说this表示本类的话，那么super就是表示父类。类加载时会先加载构造方法，super()表示父类构造方法。
		使用父类字段时super.，而且如果有父类的话会先加载父类的信息再加载子类的。
		
		向上转型(upcasting)：子类类型安全转为父类类型称为向上转型,向上转型时将子类类型安全地变为更加抽象的父类。
							子类 子 = new 父类();	向上转型
		向下转型(downcasting)：将父类类型强制转换为子类类型，为避免出错，java提供instanceof操作符。
							可以判断变量所指向的实例是否是指定类型或此类型的子类，如果引用变量为null，
							那么对让你和instanceof的判断都为false。
							父类 父 = new 子类();  or  父类 父 = (父) new 子类();
						从java14后判断instanceof后可直接转型为指定变量，避免再次强制转换。
	继承and组合(is and has):				
		不能继承没有is关系的类，但是可以使用组合，就是a(子)可以持有一个b的实例。
		组合是has的关系。
		如果父类不想子类对父类某些方法或字段进行重写，使用final进行修饰，被final修饰的是常量并且不能修改的。
		如果一个类不想被继承也可使用final进行修饰，被final修饰的不能被继承。
			final修饰符有多种作用：

			final修饰的方法可以阻止被覆写；

			final修饰的class可以阻止被继承；

			final修饰的field必须在创建对象时初始化，随后不可修改。
		
	重载(Overload)：
		一个类中一系列方法功能相同，参数不同，就可以及那个这组方法编程同名方法，即重载。
		方法名相同，参数不同，是为重载(Overload)。重载返回值通常相同。
		(个人感觉重载和创建多个构造方法差不多)
	重写(Override)：子类定义一个和父类方法名一样的方法，是重写(Override)。
		重写的话方法名、参数、返回值相同。
		
	多态：		
		多态指的是针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。
		多态特性是运行期才能动态决定调用的子类方法，针对某个类型调用某个方法，执行的实际方法可能是某个子类的重写方法。
		多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。
		Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；
		
	抽象类：
		父类方法本身不需要实现任何功能，只是为了定义方法签名，让子类进行实现，这就是抽象方法。
		抽象方法使用abstract进行修饰，类名也用abstract进行修饰。
		抽象方法本身的作用是定义一个规范，子类进行方法重写。
		子类继承抽象类，必须重写抽象类方法否则子类还是抽象类。
		抽象方法也使得程序扩展性更高，耦合性降低。
	
	面向抽象编程：
		面向抽象的本质是抽象类只定义规范。
		不需要子类就能实现业务逻辑。
		具体业务逻辑由不同子类进行实现，调用者不必关心是谁实现。
	
	接口(interface)：
		抽象类的本质是定义规范，保证所有子类都有相同的接口实现，从而体现多态。
		接口和抽象类的区别是：
			接口所有方法必须都是抽象方法，实现接口implements关键字。
			抽象类可以有抽象方法和普通方法，继承类extends关键字。
		接口中只能有抽象方法，只能！！！
		
		java只能继承一个类但是可以实现无数个接口。
		
		抽象类和接口的对比如下：
						abstract class			interface
			继承		只能extends一个class	可以implements多个interface
			字段		可以定义实例字段		不能定义实例字段
			抽象方法	可以定义抽象方法		可以定义抽象方法
			非抽象方法	可以定义非抽象方法		可以定义default方法
												default是默认方法将public改为default。
			
	术语：
		接口分java和编程：
			java接口是指interface中全是抽象方法的定义。
			编程接口是指接口规范，方法签名、数据格式、网络协议等。
	
	静态字段静态方法：
		static修饰字段或方法是为静态，静态字段只有一个共享空间，所有实例都会共享此字段。
									  普通字段都会有独立的空间，每个实例的同名字段互不影响。
		
		普通实例方法需要通过实例变量，调用静态方法则不需要，通过类名即可：类名.方法名。
		因为静态方法属于class，so静态方法内部无法访问this变量，也无法访问实例字段只能访问静态字段。
		静态方法常用于工具类：
			Arrays.sort();
			Math.random();
			也用于辅助类，如main();
		interface因为是抽象类不能定义实例字段，但可以有静态字段而且必须为final类型。
		
	包：
		jvm执行的时候，只看完整类名，so只要报名不同，类就不同。
		包作用域：
			位于同一包内，不用public、protected、private的字段和方法就是包作用域。
		import：在使用其他class时需要导入包路径，但是创建实例的时候大部分都已经自动生成了。
			·	如果import com.* 就是将这个包下所有class都导入进来。
		
	作用域：
		第一要点是，代码从上到下执行，第一行无法访问第二行的变量。
		不能直接访问不同类的变量等等。
	
	模块：
		.class是jvm看到最小可执行文件，大型程序需要很多class，不便管理，所以jar文件就是class的容器。
		java9之前开发程序时除了自己的app.jar还需要一堆第三方jar包。
		jvm自带的标准库rt.jar不能写到classpath中不然会干扰jvm正常运行，漏写了某个运行用到的jar，
		那么运行时可能抛出ClassNotFoundException，jar只是存放class的容器，并不关心class之间的依赖。
		java9开始引入模块，为了解决依赖的问题，如果a.jar必须依赖b.jar才能运行，应该给a.jar加点说明，让他
		再编译和运行的时候自动定位到b.jar,这种依赖关系的class容器就是模块。
		
		从java9开始java库将rt.jar拆分成几十个模块，以.jmod扩展名标识，在$JAVA_HOME/jmods目录下。
			每个.jmod都是一个模块，模块名就是文件名。如java.base就是java.base.jmod，模块之间的
			关系已经写到模块内的module-info.class文件，所有模块之间莫简介依赖java.base,但是它不
			依赖任何模块，可将它看作成根模块。
		将一堆class封装成jar需要打包，将class封装成模块不但要打包号要写入依赖关系。
		
		创建模块：
			如在src下创建module-info.java文件，这是模块描述文件
			运行java需要jar，jdk提供了jlink命令，只使用程序需要的jar：
				$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.w件是b明确导出可访问的包。
	
	orld --output jre/
			权限访问：
				class访问权限只在一个模块内有效，模块之间，a要访问b的某个class，必要条件是b明确的到处可访问的包。
				只有声明导出的包外部代码才允许访问。
				如想访问com.itranswarp.sample.Greeting必须导出(exports)exports com.itranswarp.sample;



Java核心类：
	字符串

	StringBuilder

	StringJoiner

	包装类型

	JavaBean

	枚举

	常用工具类
	
	字符串和编码：
		
		String：是引用类，本身也是class。编译器对其有特殊处理可用"..."表示一个字符串。
				在其内部是通过char[]数组显示的如下：
				String s = new String(new char[]{'h','e','l','l','o'});
				字符串最重要的特点就是字符串不变，是通过内部的private final char[]以及没有任何修改char[]方法实现的。
			比较：==一般表示数值，字符串比较必须使用equals()，忽略大小写使用equalsIgnoreCase()方法。
				
			提取、搜索子串：
				搜索："字符串".indexOf("串");	显示串的下标
				      "字符串串".lastIndexOf("串");		显示最后一个串的下标
					  "字符串".startsWith("字符");		判断是否从字符开始 返回布尔
					  "字符串".endWith("符串");			判断时候以符串结尾 返回布尔
					  
				提取："字符串".substring(下标); 提取指定下标及以后的字符。
					  "字符串".substring(1,2);  只提取1，2下标的字符。
	
			去除首位空白字符：
				使用trim()一处字符串首尾空字符,如:\t, \r, \n;
				trim()并没有改变字符串内容,二十返回一个新字符串。
				strip()也可以移除首位空字符,但是中文空格的\u3000也会被移除。
			判断是否为空：
				"".isEmpty();		空字符串返回true,否则为false如:"  "
				" \n".isBlank();	含空白字符串返回true否则false如:"hello"
			替换字符串：
				变量名.replace('e','a');		将变量中的所有e改为a
				正则表达式替换：
					String s = "A,,B;C ,D";
					s.replaceAll("[\\,\\;\\s]+", ","); // "A,B,C,D" 将匹配的子串统一替换为，。
			分割字符串：
				split()方法，传入正则表达式，如下：
					String s = "A,B,C,D";
					String[] ss = s.split("\\,"); // {"A", "B", "C", "D"}
			拼接字符串：
				join()静态方法进行拼接，如下：
					String[] arr = {"A", "B", "C"};
					String s = String.join("***", arr); // "A***B***C"

			格式化字符串：
				formatted()和format静态方法传入其他参数替换占位符生成新的字符串：
					String s = "Hi %s, your score is %d!";
					System.out.println(s.formatted("Alice", 80));
					System.out.println(String.format("Hi %s, your score is %.2f!", "Bob", 59.5));
				后面有几个占位符就传几个参数，参数类型要和占位符一致，如果不确定的话使用%s因为其可以显示任何数据类型。
					%s：显示字符串；
					%d：显示整数；
					%x：显示十六进制整数；
					%f：显示浮点数。
			类型转换：
				将任意基本类型或引用类型转换为字符串，使用静态方法valueOf(),这是重载方法，编译器会根据适合的参数选择合适的方法。
					String.valueOf(123);
					String.valueOf(23.23);
					String.valueOf(true);
					String.valueOf(new Object());
				将字符串转为其他类型需要根据实际情况：
					int n = Integer.parseInt("123");	int类型
					boolean b1 = Boolean.parseBoolean("true");  Boolean类型
					将字符串对应的系统变量转换为integer，Integer是int的包装类
						Integer.getInteger("java.version"); // 版本号，11
					string和char互相转换：
						char[] cs = "Hello".toCharArray(); // String -> char[]
						String s = new String(cs); // char[] -> String
	
				因为String的不变特性，如果传入对象可能改变，就需要复制而不是直接引用。
		
		字符编码：
			简介在这里：https://www.liaoxuefeng.com/wiki/1252599548343744/1260469698963456
			因为不同编码的字符集是不一样的，所以统一发布了Unicode编码，将主要语言统一就不会发生冲突了。
			UTF-8是容错力强传输过程中某些字符出错不影响后续字符，因为是靠高字节位确定字符是几个字节的，常用于传输编码。
				byte[] b1 = "Hello".getBytes(); // 按系统默认编码转换，不推荐
				byte[] b2 = "Hello".getBytes("UTF-8"); // 按UTF-8编码转换
				byte[] b2 = "Hello".getBytes("GBK"); // 按GBK编码转换
				byte[] b3 = "Hello".getBytes(StandardCharsets.UTF_8); // 按UTF-8编码转换
				以上转换编码后就变成byte类型了。
				将byte转为String：
					byte[] b = ...
					String s1 = new String(b, "GBK"); // 按GBK转换
					String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换
			注：java的String和char在内存中总是以Unicode表示。
	
		小结：
			java字符串String是不可变对象。
			字符串操作不改变原字符内容，而是返回新字符。
			常用的字符串操作：提取字符串、查找、替换、大小写转换等。
			java使用unicode编码表示string和char。
			转换编码就是将string和byte[]转换，需要指定编码。
			转为byte[]优先考虑UTF-8编码。
	
	StringBuilder：
		可以使用+拼接字符串但是用for循环拼接字符串的话，每次循环创建新的字符串，抛弃旧的
		大部分都是临时对象，浪费内存影响GC(垃圾回收)效率。
		可使用StringBuilder，可变对象可以预分配缓冲区，所以新增字符串时不会创建新的临时对象。
		(当然拼接的时候还是要使用for，只是将string类型改为StringBuilder类型罢了)
		也可以进行链式操作：
			var sb = new StringBuilder(1024);
				sb.append("Mr ")
				  .append("Bob")
				  .append("!")
				  .insert(0, "Hello, ");
			System.out.println(sb.toString());
		StringBuffer是java早期的StringBuilder线程安全版本，通过同步保证多个线程操作StringBuffer也是安全的，
		但是同步会让执行速度下降。
		StringBuilder和StringBuffer接口完全相同，现在没有必要使用StringBuffer。
	
	StringJoiner:
		new StringJoiner(",");就是遍历数组的时候中间值与值之间加上，号，在使用stringjoiner的变量.add添加值即可。
		如果需要在值首位添加数据new StringJoiner(",", "头", "尾");	toString();是转为string类型。
		不指定首尾时可用静态方法String.join()更方便，因为在内部使用StringJoiner拼接字符。
		String.join(",", 数组名);	自动进行拼接
		
		
	包装类：
		java数据类型两种：基本：byte、short、int、long、boolean、float、double、char
						  引用：所有class和interface类型。
			引用类型能为null，基本类型不行。
			将基本类型视为引用的话，用到包装类。
			以下时基本类型的包装类，所有的包装类都是不变类：
				boolean			java.lang.Boolean
				byte			java.lang.Byte
				short			java.lang.Short
				int				java.lang.Integer
				long			java.lang.Long
				float			java.lang.Float
				double 			java.lang.Double
				char			java.lang.Character
			
			int和integer是可以互换的，编译器自动在int和integer之间转型。
			直接将int变为integer的复制方式，为自动装箱(Auto Boxing)，integer转为int的就是自动拆箱(Auto Unboxing)。
			自动拆装箱只发生在编译阶段，是为了少写代码。但会影响代码执行效率，编译后的class严格区分基本和引用的。
			自动拆箱时可能报NullPointerException。
			
			包装类是引用类型比如integer所以比较时用equals()。
			integer不可变类，如设置了值为1，第二次在设置变量b=2，那么值还是1。此例子不标准
			integer.valueOf()对于较小的数，始终返回相同的实例所以==恰好为true。
			integer==为true是因为，valueof返回之前，进行判断当前的值是否在-128-127之间，
			如果存在就直接返回引用不用重新开辟空间，
			如果不存在就创建一个新对象，
			利用缓存提高车光绪执行效率节约内存，但是还是尽量使用equals进行数值比较。
			可能integer.valueof可能始终返回同一个integer实例，所以：
				Integer n = new Integer(数值);
				Integer n = Integer.valueOf(数值);
				第二个好一点因为第一个总是创建新的实例，而且第二个将内部优化留给integer实现者去做。
			能创建新对象的静态方法称为静态工厂方法。
			Integer.valueOf就是，它尽可能返回缓存实例以节省内存。
			创建新对象时，优先选用静态工厂而不是new操作符。
		进制转换：
			Integer的静态方法：
				parseInt()将字符串解析成一个整数
			将整数格式化成指定进制的字符串：
				Integer.toString(100); 			"100",表示为10进制
				Integer.toString(100, 36); 		"2s",表示为36进制
				Integer.toHexString(100);  		"64",表示为16进制
				Integer.toOctalString(100); 	"144",表示为8进制
				Integer.toBinaryString(100);  	"1100100",表示为2进制
			顺带一提String好像在内存中只用二进制显示。
			程序的重要原则就是数据存储和显示分离。
			整数和浮点的包装类型都继承自number，so可直接通过包装类型获取各种基本类型。
	
	JavaBean(组件):	
		封装实体类为了让外部访问设置值，而创造的getset方法，这种方法称为javabean。
		boolean比较特殊读方法get变成is(具体是get还是is根据情况来)
		ecplise的getset的快捷键：Shift+Alt+S；或者 右键Source里面的getset。
	枚举JavaBean属性：
		例如：
		BeanInfo info = Introspector.getBeanInfo(Person.class);
        for (PropertyDescriptor pd : info.getPropertyDescriptors()) {
            System.out.println(pd.getName());
            System.out.println("  " + pd.getReadMethod());
            System.out.println("  " + pd.getWriteMethod());
        }
		使用Introspector枚举javabean的所有属性以及读写方法。
		class属性是从object继承的getClass()方法的。
	
		小结：JavaBean是一种命名规范的class，用getset定义熟悉。
			  使用Introspector.getBeanInfo()可以获取属性列表。
	
	枚举类：
		枚举使用，进行分割如：a，b，c，d;
		enum是枚举类，枚举是类型，每个枚举类型是不一样的。
		枚举的好处是，不同枚举不能相互比较或赋值，因为类型不符。
		也就是说a枚举类复制称为b枚举类的值，a只能给a复制，因为枚举类型不一样所以会报类型错误。
		enum比较方式:
			enum是引用类型，但是比较不用equals而是用==因为，enum每个常量在jvm中只有一个唯一实例。
		enum类型：
			enum定义的枚举类和class没有任何区别，enum定义类型就是class只不过有几个特点：
				定义的enum总是继承java.lang.Enum并且无法被继承。
				只能定义出enum的实例，无法通过new创建enum实例。
				定义的每个实例都是应用类型的唯一实例。
				enum可用于switch语句。
		enum是一个class，每个枚举的值都是class实例，so实例有些方法：
			枚举类.枚举.name();		返回枚举名称。
			枚举类.枚举.ordinal();	返回定义的常量的顺序，从0开始。
			枚举类中是可以定义字段的(但是尽量定义常量的)。
			可以给每个枚举常量添加字段如：
				a(1),b(2),c(3),d(4);
				这样就不用担心顺序变化，新增枚举常量时要指定个int值。
			对枚举常量调用toString()会返回name()一样的字符串，但toString()可以被重写name()不行。
			判断枚举常量的名字必须使用name()绝不能调用toString()。
		因为枚举类天生的类型信息和有限个枚举常量，所以更适合switch语句。
			
		小结：
			enum定义枚举，编译器会编译为final class ClassName extends Enum{}。
			通过name()获取常量定义的字符串，不要使用toString()。
			可为enum编写构造方法、字段、方法。
			enum的构造方法要声明private，尽量使用final。
	
	记录类：
		String、Integer都是不变类，不变类的特点：
			定义class时使用final，无法派生子类。
			每个字段使用final，保证创建实例后无法修改任何字段。
		
		record(重新编码):
			java14后引入了Record类，类需要extends Record，定义语法是public record 方法名（）{}。
			使用record关键字可以一行写出一个不变类。
		
	BigLnteger：
		常用方法链接：https://blog.csdn.net/sobermineded/article/details/79299435
		java中，cpu原生提供整数最大范围是64位long型整数。使用long型整数可以直接通过cpu指令进行计算，速度非常快。
		java.math.BigInteger类用来表示任意大小整数，其内部用int[]数组模拟非常大的整数。
			BigInteger bi = new BigInteger("1234567890");
			System.out.println(bi.pow(5)); // 2867971860299718107233761438093672048294900000
		BigInteger做运算的时候只能用实例方法如+：
			BigInteger i1 = new BigInteger("1234567890");
			BigInteger i2 = new BigInteger("12345678901234567890");
			BigInteger sum = i1.add(i2); // 12345678902469135780
		和long相比，BiGInteger没有范围限制但是速度慢，可将BigTnteger转为long。
			BigInteger i = new BigInteger("123456789000");
			System.out.println(i.longValue()); // 123456789000
			System.out.println(i.multiply(i).longValueExact()); 
			// java.lang.ArithmeticException: BigInteger out of long range
		使用longValueExact()时，超出long范围后会抛出ArithmeticException。
		BigInteger和Integer、Long都是不可变类，也继承自number，Number定义转换为基本类的方法：
			转为byte：		byteValue()
			转为short：		shortValue()
			转为int:		intValue()
			转为long:		longValue()
			转为float: 		floatValue()
			转为double:		doubleValue()
		如果BigInteger表示范围超出了基本类型的范围，转换时丢失高位信息，结果不一定准确的。
		要准确的转换成基本类型，使用intValueExact()、longValueExact()等方法，转换时超出范围，
		直接抛出ArithmeticException异常。
		
	BigDecimal：
		和BigInteger类似，它可以表示任意大小且精度完全准确的浮点数。
		实例一个BigDecimal对象db：
			db.multiply(db);					如果值是3，那么就是3*3，multiply是乘。
			db.scale(db);						取浮点的小数。
			db.stripTrailingZeros();			去掉末尾的0，如果使用scale查看返回负数的话
												就是这个数是整数并且,-2就是就是两个0。
			指定精度：
				db.setScale(4,RoundingMode.HALF_UP)	四舍五入(看着语句的意思应该是向上取整)根据第一个值保留小数。
				db.setScale(4,RoundingMode.DOWN);	截断根据第一个值保留小数，此处保留4位小数。
			如果有两个bigdecimal对象1and2，那么创建一个该对象数组
				1.divideAndRemainder(2);	做出发的同时求余数
		在比较两个bigdecimal值时候相等时，使用equals()不但要求两个值相等还要求scale()相等。
		必须必须必须使用compareTo()比较，它根据两个值大小分别返回负、正数和0，分别表示> < =。
		源码中BigDecimal是通过BigInteger和scal表示的，BigInteger表示完整整数，scal表示小位数。
		当然了BitDeicmal也是继承自Number的，也是不可变对象。
		
		因为其表示精确的小数，常用于财务计算。
	
	常用工具类：
		Math：
			进行数学计算的类，提供大量的静态方法便于实现数学计算。
			求绝对值：
				Math.abs(-100);		整数and0绝对值是其本身，负数绝对值是它相反数。
			取最大最小：
				Math.max(10,1);		选取值中最大的
				Math.min(13.1,1.2);	选取值中最小的
			计算xy次方：
				Math.pow(2,10);		2的10次方=1024
			计算√x：	
				Math.sqrt(2); // 1.414...
			计算ex次方：
				Math.exp(2); // 7.389...
			计算以e为底的对数：
				Math.log(4); // 1.386..
			计算以10为底的对数：
				Math.log10(100); // 2
			三角函数：
				Math.sin(3.14); // 0.00159...
				Math.cos(3.14); // -0.9999...
				Math.tan(3.14); // -0.0015...
				Math.asin(1.0); // 1.57079...
				Math.acos(1.0); // 0.0
			Math还提供了几个数学常量：
				double pi = Math.PI; // 3.14159...
				double e = Math.E; // 2.7182818...
				Math.sin(Math.PI / 6); // sin(π/6) = 0.5
			生成一个随机数x，x的范围是0 <= x < 1：
				Math.random(); // 0.53907... 每次都不一样
				这个生成随机数的类型只能是double，例子：
					double a = Math.random();	现在的取值范围0，1
					double b = 10;
					double c = 30;
					double d = a*(c-b)+b; 	现在的取值范围是10-30的小数
					long e = (long) d;		使用类型的话e的取值范围就是10-30的整数
					Systom.out.println(d);
			Random：
				创建伪随机数，是指定一个初始的种子，产生的水机数序列是完全一样的。
				生成随机数的方法：
					nextInt()、nextLong()、nextFloat()、nextDouble()
					Random r = new Random();
					r.nextInt(); // 2071575453,每次都不一样
					r.nextInt(10); // 5,生成一个[0,10)之间的int
					r.nextLong(); // 8811649292570369305,每次都不一样
					r.nextFloat(); // 0.54335...生成一个[0,1)之间的float
					r.nextDouble(); // 0.3716...生成一个[0,1)之间的double
				SecureRandom:
					有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，
					而我们想要的是一个不可预测的安全的随机数，SecureRandom就是用来创建安全的随机数的：
					SecureRandom sr = new SecureRandom();
					System.out.println(sr.nextInt(100));
					密码学中，安全的随机数非常重要，不使用安全的伪随机数，所有加密体系都将被攻破，
					必须使用secureRandom产生安全的随机数。
					详情：https://www.liaoxuefeng.com/wiki/1252599548343744/1260473555087392
			
			Math：数据计算
			Random：生成伪随机数
			SecureRandom：生成安全的伪随机数

异常处理：
	
	java异常：
		值为int但输入String时会报数字形式错误异常 							NumberFormatExcrption
		程序像读取文件，但是计算机没有或者被删掉了报文件未被创建			FileNotFoundException	
		调用方法获知调用失败的信息：
			1.约定返回错误码：
				如：处理个文件返回0成功返回其他整数表示约定的错误码。
			2.语言层面上提供个异常处理机制：
				java内置了一套异常处理机制总是使用异常表示错误。
				异常是一种class，so本身带有类型信息。异常可以在任何地方抛出，但是要在上层捕获，
				这样就和方法调用分离了。
		如下是异常的继承关系：
					 ┌───────────┐
                     │  Object   │
                     └───────────┘
                           ▲
                           │
                     ┌───────────┐
                     │ Throwable │
                     └───────────┘
                           ▲
                 ┌─────────┴─────────┐
                 │                   │
           ┌───────────┐       ┌───────────┐
           │   Error   │       │ Exception │
           └───────────┘       └───────────┘
                 ▲                   ▲
         ┌───────┘              ┌────┴──────────┐
         │                      │               │
┌─────────────────┐    ┌─────────────────┐┌───────────┐
│OutOfMemoryError │... │RuntimeException ││IOException│...
└─────────────────┘    └─────────────────┘└───────────┘
                                ▲
                    ┌───────────┴─────────────┐
                    │                         │
         ┌─────────────────────┐ ┌─────────────────────────┐
         │NullPointerException │ │IllegalArgumentException │...
         └─────────────────────┘ └─────────────────────────┘
		Throwable是异常的根继承自object，他有两个体系：error和exception
		error表示严重错误，程序对此无能为力如：
			OutOfMemoryError：内存耗尽
			NoClassDefFoundError：无法加载某个Class
			StackOverflowError：栈溢出
		exception是运行时错误，可以被捕获并处理如：
			NumberFormatException：数值类型的格式错误
			FileNotFoundException：未找到文件
			SocketException：读取网络失败
		又或者是程序逻辑不对造成如：
			NullPointerException：对某个null的对象调用方法或字段
			IndexOutOfBoundsException：数组索引越界
		exception分两大类：
			1.RuntimeException及它的子类
			2.非RuntimeException（包括IOException、ReflectiveOperationException等等）
		java规定：
			必须捕获的异常包括Exception及其子类，不包括RuntimeException及其子类，这种类型称为Checked Exception。
			不需要捕获的异常，error及其子类，RuntimeException及其子类。
		
		捕获异常：
			通常使用try..catch语句，将可能异常的代码放到try{}下，使用catch捕获对应的exception及其子类。
			很多地方不捕获异常将会报错，捕获后将返回异常信息。
			
			方法定义的时候使用throws xx表示改方法可能抛出异常类型。调用方在调用的时候必须强制捕获否则编译报错。
			也就是说可见本类的异常进行抛出，但是其他类调用此类时必须强制捕获异常否则报错。
			如果不捕获的话可以一直throws 异常类型进行抛出。
			如果在main方法还是抛出后，那么一旦发生异常程序立刻退出。
			
			所有异常都能调用printStackTrace()方法打印异常栈，是一个简单有用快速打印异常的方法。
		
		结：
			Java使用异常来表示错误，并通过try ... catch捕获异常；

			Java的异常是class，并且从Throwable继承；

			Error是无需捕获的严重错误，Exception是应该捕获的可处理的错误；

			RuntimeException无需强制捕获，非RuntimeException（Checked Exception）需强制捕获，或者用throws声明；

			不推荐捕获了异常但不进行任何处理。
		
	捕获异常：
		多层catch语句：
			使用多个catch语句，每个分别捕获对应的exception及其子类。JVM捕获到异常后，会从上到下匹配catch语句，
			匹配到某个catch后执行catch代码，然后不再继续匹配。
			多个catch只有一个被执行，并且顺序很重要，子类写前否则就会被其他高级的异常类执行了。
		
		finally语句：
			无论发生什么都会运行finally下的代码，finally顺序在catch后面。
			finally不是必须的可写可不写，finally总是最后执行。
		
		捕获多种异常：
			某些异常处理逻辑相同，但是异常本身不存在继承关系，就得编写多条catch子句。
			
	抛出异常：
		异常传播：
			某方法抛出异常，当前方法没有抛出，异常就会被抛到上层调用方法，直到被try捕获为止。
			异常.printStackTrace()可以打印出方法的调用栈。
		抛出异常：
			发生错误时，如输入非法字符就可抛出异常。
			如果方法捕获异常后，又在carch中抛出新的异常，就相当于把抛出的异常类型转换了。
			捕获异常并抛出时，一定保留住原始异常否则很难定位第一案发现场。
			如果在catch中抛出异常那么，不会影响finally的运行，JVM会先执行finally然后抛出异常。
		异常屏蔽：
			如果执行finally时抛出异常，那么catch准备抛出的异常就消失了，so只能抛出一个异常，
			没有被抛出的被称为"被屏蔽"的异常(Suppressed Exception)。
			如果要获知所有异常先用Exception对象保存原始异常，后调用Throwable.addSuppressed(),
			把原始异常添加进来，最后在finally抛出。
		异常打印的详细的栈信息是找出问题的关键！
	
	自定义异常：
		Java标准库定义的常用异常包括：
			Exception
			│
			├─ RuntimeException
			│  │
			│  ├─ NullPointerException
			│  │
			│  ├─ IndexOutOfBoundsException
			│  │
			│  ├─ SecurityException
			│  │
			│  └─ IllegalArgumentException
			│     │
			│     └─ NumberFormatException
			│
			├─ IOException
			│  │
			│  ├─ UnsupportedCharsetException
			│  │
			│  ├─ FileNotFoundException
			│  │
			│  └─ SocketException
			│
			├─ ParseException
			│
			├─ GeneralSecurityException
			│
			├─ SQLException
			│
			└─ TimeoutException
		当我们在代码中需要抛出异常时，尽量使用JDK已定义的异常类型。例如，参数检查不合法，应该抛出IllegalArgumentException。
		大型项目可定义新的异常类型，保持合理的异常继承体系是很重要的，常见的作法是定义个BaseException作为根异常，
		从其派生出各种业务类型的异常
		
		如果期待的运行代码没有发生异常一定一定一定加上try。
		
	
	NullPointerException(空指针、NPE)：
		俗称NPE，如果一个对象为null，调用其方法或字段就会产生空指针，它通常是由JVM抛出的。
		指针源自c，java中没有指针。我们定义的变量实际上是引用，Null Pointer确切是Null Reference但两者区别不大。
		处理NullPointerException：
			首先，必须明确，处理空指针是种代码逻辑错误，原则上遇到早暴露、早修复，禁止使用catch隐藏编码错误：
				catch(NullPointerException e)这样的是禁止的。
		好的编码习惯可以极大降低空指针的产生，如声明变量为" "而不为null。
		
		java14新增的功能是空指针时显示报错详细信息，默认关闭，可给jvm添加参数启动：
			java -XX:+ShowCodeDetailsInExceptionMessages Main.java
			此命令的cmd窗口需要在项目文件下打开并保证和Main(也可以是其他需要运行类)处在同一级。
			但是经过我测试发现只能在cmd窗口运行命令才会有详细的报错信息，ecplise(ide开发环境)没有。
			
	断言(Assertion)：
		它是一种调试程序的方式，java中使用assert关键字实现断言。
		assert x => 0;	这是条件，如果条件成立则正常输出，否则抛出AssertionError。
		使用断言时可添加断言消息：assert x >=0 : "断言失败***"	
		断言失败AssertionError会带上断言失败**便于调试，在断言后面添加冒号，后加上断言消息即可。
		JVM是默认关闭断言指令，即使有assert关键字就自动忽略了。
		执行断言的话要在命令行输入如下命令：
			-ea:com.itranswarp.sample.Main
				ea是-enableassertions简写
				后面的路径是指定启用断言的类如果包路径后加上...不写类的话是再这个包启动断言。
		实际上很少使用断言，更好是编写单元测试。
		断言是一种调试方式，断言失败会抛出AssertionError，只能在开发和测试阶段启用断言。
	
	使用JDK Logging(日志)：
		程序结果与预期不符时可使用logging，用来代替输出语句。
			可以设置输出样式，避免自己每次都写"ERROR: " + var；
			可以设置输出级别，禁止某些级别输出。例如，只输出错误日志；
			可以被重定向到文件，这样可以在程序运行结束后查看日志；
			可以按包名控制日志级别，只输出某些包打的日志；
			可以……
		日志会显示输出的详细信息如事件、类等等。
		使用方法是，先声明对象Logger l=Logger.getGlobal();用对象调用级别，如：
		l.fine("输出语句");
		日志定义了7个级别限制：
			SEVERE
			WARNING
			INFO
			CONFIG
			FINE
			FINER
			FINEST
			info是默认级别，其以下是不会打印出来的，好处是调整级别就可以屏蔽很多调试相关的日志输出。
			
		logging再jvm启动时读取配置文件完成初始化，一旦运行main()方法就无法修改配置。
		需要在JVM启动时传递参数-Djava.util.logging.config.file=<config-file-name>，uoyi
		java标准库内置的logging使用不广泛。
	
	使用Commons Logging(通用日志)：
		和logging不一样，它是第三方日志库，由Apache创建的日志模块。
		特色是，可以挂接不同的日志系统后通过配置文件指定挂接的日志系统，默认情况下，自动搜索并使用Log4j
		(另一个流行的日志系统)，如果没有找到log4j再使用JDK logging。
		
		第一步，通过LogFactory获取Log类的实例； 第二步，使用Log实例的方法打日志
			Log log = LogFactory.getLog(Main.class);
			log.info("start...");
			log.warn("end.");
		但是运行的时候会报找不到类的错误，因为它是第三方提供的，所以要提供个jar包(commons-logging-1.2.jar)，
		将jar和运行类放在同一文件下，打开命令行，先编译运行文件如：javac -cp commons-logging-1.2.jar Main.java
		编译成功后当前文件夹会多出个Main.class文件，
		然后执行Main文件：java -cp .;commons-logging-1.2.jar Main
		如果在Linux或macOS下运行：
						  java -cp .:commons-logging-1.2.jar Main
		上语句有部分：一个是.还有commons-logging-1.2.jar，使用;分割。
		.表示当前目录，没有它，JVM不会在当前目录搜索Main.class,就会报错。
		Commons Logging定义了6个日志级别(默认是info)：
			FATAL
			ERROR
			WARNING
			INFO
			DEBUG
			TRACE
		使用commons logging，在静态方法中引用log，通常定义个静态变量类型：
			  static final Log log = LogFactory.getLog(Main.class);
		实例方法中通常定义实例变量
			 protected final Log log = LogFactory.getLog(getClass());
		
		实例log获取方式有LogFactory.getLog(getClass());
						 LogFactory.getLog(当前类.getClass());
			第一个方式的好处是子类可以使用父类的log实例。
		
		由于java类动态特性，子类获取的log字段实际上相当于LogFactory.getLog(子类本类.class)，但却是从父类继承的，无需修改代码。
		日志方法除了info(String)，info是日志打印输出。
		还有重载方法info(String,Throwable)。
		log.error(String,exception)打印异常。
		Commons Logging是使用最广泛的日志模块；

		Commons Logging的API非常简单；

		Commons Logging可以自动检测并使用其他日志模块。
				
	
	使用Log4j：
		日志实现可以使用Log4j。它是一个组件化设计的日志系统，构造大致如下：
			log.info("User signed in.");
			 │
			 │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
			 ├──>│ Appender │───>│  Filter  │───>│  Layout  │───>│ Console  │
			 │   └──────────┘    └──────────┘    └──────────┘    └──────────┘
			 │
			 │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
			 ├──>│ Appender │───>│  Filter  │───>│  Layout  │───>│   File   │
			 │   └──────────┘    └──────────┘    └──────────┘    └──────────┘
			 │
			 │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
			 └──>│ Appender │───>│  Filter  │───>│  Layout  │───>│  Socket  │
				 └──────────┘    └──────────┘    └──────────┘    └──────────┘
		log4j输出一条日志时，它会自动通过不同的appender将同一条日志输出到不同目的地。
			console：输出到屏幕；
			file：输出到文件；
			socket：通过网络输出到远程计算机；
			jdbc：输出到数据库
		日志输出过程中通过filter过滤哪些log需被输出，哪些不需要，如：仅输出ERROR级别的日志。
		最后通过layout格式化日志信息，如自动添加日期、事件、方法名等信息。
		实际使用时并不关心它的api，而是通过配置文件进行配置。
		配置文件详情：https://www.liaoxuefeng.com/wiki/1252599548343744/1264739436350112
		配置log4j较繁琐，配置完成后非常方便，凡是info(默认)级别的日志会自动输出到屏幕，
		而error级别的，不但会输出到屏幕，同时会输出到文件。且日志文件达到指定大小，log4j
		就会自动切割新的日志文件，最多保留10份(详情根据配置来)。
		因为Log4j也是三方库，先下载jar包将3个jar包放入classpath中：
			og4j-api-2.x.jar
			log4j-core-2.x.jar
			log4j-jcl-2.x.jar
		因为commons logging会自动发现使用log4j，所以将commons的jar包也放入classpath。
		打印日志按Commons Logging的写法即可。
		
		结：
			通过Commons Logging实现日志，不需要修改代码即可使用Log4j；

			使用Log4j只需要把log4j2.xml和相关jar放入classpath；

			如果要更换Log4j，只需要移除log4j2.xml和相关jar；

			只有扩展Log4j时，才需要引用Log4j的接口（例如，将日志加密写入数据库的功能，需要自己开发）。
					
			
	使用SLF4J和Logback：
		Commons Logging和Log4j一个负责日志API，一个负责日志底层，搭配使用非常便于开发。
		SLF4J类似Commonslogging也是日志接口，logback类似log4j是日志实现。
		commons的时候打印日志需要拼接字符串，slf4j的话就能使用占位符，飞创简洁，占位符表示为{}。
		对比一下Commons Logging和SLF4J的接口：
			Commons Logging							SLF4J
			org.apache.commons.logging.Log			org.slf4j.Logger
			org.apache.commons.logging.LogFactory	org.slf4j.LoggerFactory
			区别就是log变成了logfactory。
		使用方法是将jar包放到classpath下，jar名：
			slf4j-api-1.7.x.jar
			logback-classic-1.2.x.jar
			logback-core-1.2.x.jar
		然后使用SLF4J的Logger和LoggerFactory即可。和Log4j类似，我们仍然需要一个Logback的配置文件，
		把logback.xml放到classpath下，配置如下：				
			https://www.liaoxuefeng.com/wiki/1252599548343744/1264739155914176
		
		结：
			SLF4J和Logback可以取代Commons Logging和Log4j。

			始终使用SLF4J的接口写入日志，使用Logback只需要配置，不需要修改代码。
			
反射(Reflection)：			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
					
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
					
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
					
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
					
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
					
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
					
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
					
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
					
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
					
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
					
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
					
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
					
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
	
	
	