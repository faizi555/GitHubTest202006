Math.random()*10;	生成随机数*10，就是生成10以内不包括10，从0开始。


JDK文件解析：
	java安装bin目录下有很多可执行文件。
	java：是jvm，运行java程序就是启动jvm，然后可以让jvm执行指定的编译后的代码。
	javac：是java编译器，用于将java源码文件(.java后缀的文件)编译为java字节码文件(.class结尾)。
	jar：用于将一组.class文件打包成一个.jar文件，便于发布。
	javadoc：用于从java源码中自动提取注释并生成文档。
	jdb：java调试器，用于开发阶段的运行调试。

使用cmd运行java文件：
	创建一个文本文件写个类，类名和文件名一致，文件后缀改为java。
	先用javac将java文件编译成class字节码文件，然后使用java命令执行字节码文件
	Hello.java  >>compile>>  Hello.class  >>execute>>  Run on JVM
	source code	   (编译)	   byte code	 (执行)
	(源码文件)				  (字节码文件)
	
	可执行文件javac是编译器，可执行文件java是虚拟机。
	在保存java文件下打开cmd窗口，
	javac Hello.java	编译java文件，将java编译成class
	java  Hello.class	执行class文件
	以上步骤是必须的，但是在java11后加入了新的功能，可以运行单个文件源码了！
	也就是说可以直接运行java了，不需要使用javac编译成class文件了。
	但是在实际项目中很少有不依赖第三方库的java源码，大多情况下无法直接运行java源码文件，因为它需要以来其他的库。
	定义类的时候可以不写public也能正常编译，但是此类无法从命令行执行。
	java入口规定方法必须是静态的，方法名必须为main，括号内参数必须是String数组。

常用注释：
	单行注释：//
	多行注释：/*开头    */结尾
	特殊多行：/**   	*/结尾，中间每行以*开头
	
	
注：代码是按顺序执行的！！！	
	
java規定：
	类名以大写开头，方法名小写开头驼峰规则。
	public为访问修饰符，static是修饰符。
	方法上加上DOTO是等待后续修改或编写的方法。

基本数据类型：
	整数类型：byte、short、int、long
	浮点类型：float、double
	字符类型：char
	布尔类型：boolean
	计算机内存最小储存单元是字节(byte)，一个字节是一个8位二进制数，即8个bit(位)。
	它的二进制表示范围从00000000~11111111，换算成十进制0~255，换算成十六进制是00~ff。
	(身为数学渣子的我，从廖老师网站搬过来的)
	
	内存单元从0开始编号，称为内存地址，每个内存单元可看作是一间房间，内存地址是门牌号。
	一个字节是1byte，1024字节是1k，1024k是1m，1024m是1g，1024g是1t，一个拥有4t内存的计算机字节数量：
	4T = 4 x 1024G；
	   = 4 x 1024 x 1024M；
	   = 4 x 1024 x 1024 x 1024K；
	   = 4 x 1024 x 1024 x 1024 x 1024；
	   = 4398046511104；
	
	不同数据类型占用的字节也不一样：
	byte   	1	  整型
	short  	2	  整型
	char   	2	  字符型
	float  	4	  浮点
	int	   	4	  整型
	long   	8	  整型
	double 	8	  布尔
	因为不了解数学，一下只做了解：
		java定义的带符号的整型。最高位的bit表示符号位(0位正，1为负)
		浮点类型是小数，因为小数点可以向前或向后浮动，所以称为浮点，对于float浮点类型数值后需加上f，如1.33f。
		布尔只有true和false两个值，数值比较运算也可替代true和false如：false1=1>2	true=1<2。
		char只能保存一个字符使用单引号''。
		String字符串引用类型使用双引号""。
		引用类型类似C语言的指针，内部存储一个地址，指向某个对象在内存中的位置涉及类和数据库(数据库学的细碎后面再说)。
		常量需要在变量前加上final修饰符，常量名通常全部大写，常量值是不能被改变的，枚举enum相似，只是枚举定义的是类。
	
	var关键字：有事类型名过长可将变量的类型写为var：var s = new Shool(); 效果等同于  shool s = new shool();
			   因为编译器会根据赋值语句自动推断变量的类型。
	变量存在作用域即作用范围，在同一个或同一个中的{}花括号中生效，如果超出范围，编译器会报错。
	
	整数运算：
		java的整数遵循四则运算规则，可以任意嵌套小括号，括号内优先运算。
			
		自增减：++n的话表示先加1再引用n，n++则相反是先引用再加1。
		移位运算二进制中，左移是乘2，右移是除2。
		位运算：
			&：相同为1，不同为0。
			|：任意为1，结果为1。
			~：0，1互换，输入0时结果为1，反之亦然。
			^：两个数值不同为1，否则为0。
		运算符优先级：
					()
					! ~ ++ --
					* / %
					+ -
					<< >> >>>
					&
					|
					+= -= *= /=
		
		注意++写在前面和后面计算结果是不同的，++n表示先加1再引用n，n++表示先引用n再加1。
		不建议把++运算混入到常规运算中，容易自己把自己搞懵了。(搬运廖老师的原话，谁做项目写++n，n++的钻简直牛角尖，虽然是因为我不会)。
		自动类型转换发生在字节低转为字节高。
		强制类型转换字节高转为字节低，但是字节高转为字节低时会损失精度，导致结果不准确。
	浮点数运算：
		浮点数只能做加减乘除运算，不能做位运算和移位运算。
		浮点数虽然范围大但是常常无法精准表示。
		0.1在计算机中无法精确表示，因为十进制0.1转成二进制时无限循环小数。
		如果小数强转为整数类型的话，小数.后的值会被舍弃如，12.3和12.7皆为12。
		整数和浮点进行运算的时候整数自动转为浮点类型。
	布尔运算：
		只有true和false	；
			比较运算符：>，>=，<，<=，==，!=
			与运算 &&
			或运算 ||
			非运算 !
		关系运算符的优先级从高到低依次是：
			!
			>，>=，<，<=
			==，!=
			&&
			||
		布尔里有一种短路运算：
			x1 && x1 如果x1为false时x2不再进行运算，第一个值为false时不再进行运算直接返回false。
			如果x1为true时，第二个值错误不能进行运算时，会报错，这样来说短路也相当于是一种保护机制。
		三元运算符：
			表达式：成功？失败
			意思是如果a>b的话，就显示：后的语句，如果a<b的话就显示？后的语句。
	字符和字符串：
		字符时基本数据类型，是charrcter的缩写，保存一个unicode字符。
		查看字符在unicode中的编码只需要将char赋值给int即可。
		字符串常见的转义字符：
			\" 表示字符"
			\' 表示字符'
			\\ 表示字符\
			\n 表示换行符
			\r 表示回车符
			\t 表示Tab
			\u#### 表示一个Unicode编码的字符
			可以使用+将多个""进行连接效果和一个""一样
			如果使用+连接字符串和其他数据类型会将其他数据类型自动转为字符串再进行连接。
		从java13开始使用"""...."""表示多行字符串和/*...*/效果差不多。
		而且字符串是不可变的，变的是指向：
			如果创建了两个s字符串
				String s = "aa";
				String s = "bb";
				会在内存中创建两个变量aa和bb，s只是一个指针的效果，s="aa";时候虚拟机创建了aa字符串，
				然后用变量s指向它，第二次s="bb";时虚拟机创建bb并且s指向它。
				当然如果a="aa";已经创建aa变量了，b="aa";时b也只是去内存中指定了aa而已，也就是说aa在内存中只创建了一次。
			null和""是有区别的，null是没有值，"是为空的有效字符串。
	数组：
		数组可以是值类型或引用类型，但是数组本身是引用类型。
		多个相同的数据类型可以使用数组进行保存。
		int [] name = new int[2]; 第二个[]中的数字为数组的个数，数组下标为0,并且规定几个必须创建几个。
		name[0] = 1;
		name[1] = 2;
		name.length使用此语法获取数组大小。
		name[1]查看下标为1的数据，输入几查看几。
		int [] name = new int [] {1,2,3,4}; 使用此方式不用指定数组大小，输入保存的数据编译器自动推算数组大小。
		int [] name = {1,2,3,4}; 这是最简洁的创建数组方式。
		
流程控制：
	System.out表示输出流	System.in表示输入流
	语句从上到下按顺序执行。
	输出语句：System.out.print();	输出后不换行。
			  System.out.println(); 输出后换行。
			  ecplise中输入sout和sys使用alt+/快捷键快速生成。
			  占位符	说明
				%d		格式化输出整数
				%x		格式化输出十六进制整数
				%f		格式化输出浮点数
				%e		格式化输出科学计数法表示的浮点数
				%s		格式化字符串
	输入：先创建Scanner对象。
		Scanner scanner = new Scanner(System.in);
		scanner.nextLine();		输入字符串
		scanner.nextInt();		输入整数
	
	switch语句：使用多重if判断的话，switch更加清晰。
		switch(){
		case 1:
			break;
		case 2:
			break;
		default:
		}
		如值=1就进入第一层，因为case具有穿透性，不写break的话，会将下一层也输出，如果下一层也没break，就滚雪球了。
		default是默认值，case的顺序不影响逻辑。
		switch条件值也可以是字符串或者枚举。
		从java12开始switch语句更加简洁化，使用模式匹配保证只有一条路径会被执行，并且不需要break。
		switch(标准值){
			case "条件值" -> 语句 ;
			case "条件值" -> 语句 ;
			case "条件值" -> {语句 };
			default ->	语句;
		}
		以上是java12后的语句，如果写逻辑判断等有多个语句的话可用{}进行扩盖，并且新语法使用->。
		可以将swithc的值作为变量进行设置int xx = switch(){}
		可以case"123","312"使用,设置多个条件。可以使用yield返回一个值作为返回值。
	while循环：根据条件做循环就按，条件满足时退出循环
		while(条件表达式){
			循环语句
			值++；
		}
		开始时先判断条件表达式，如果位true就运行，false就终止跳出while循环。
		while必须在最底层使用条件值++，否则无限循环
	do{
		语句;
		值++;
	}while(条件表达式);
	dowhile较while不同，
	while先判断再执行，dowhile先执行再判断。
	
	for循环：最便利的循环之一，在每次循环后更新计数器计数器通常为1不需要写n++。
		for(int i=0; i<=100; i++){
			i<=100是条件；
			i++;是自增；
			int i=0;声明一个计数器并指定默认值；
		}
		对计数器变量的修改尽量在for循环中。
	for each使用此循环遍历数组,也能遍历输出map，list等集合。
		int [] a={1,3,5,7,9};
		for(int b : a){
			 System.out.println(b);
		}
		
		for循环可以访问数组索引，for each直接迭代每个数组元素，无法获取索引。
		
		在while和for中都能使用break和comtinue语句(switch也能用)
		在循环中判断加上break，当数值到达xx时就break，
		注意break只挑出当前那层循环，如果有两层在最里层加上break，就是跳出里层循环，外层循环不会结束。
		comtinue提前结束本次循环，comtinue后的语句不执行，然后继续循环。
	
数组：Arrays.toString(数组名);快速打印数组内容
	  Arrays.sort(数组名);对数组进行排序，但实际上时修改了数组本身。
	冒泡排序的特点，每一轮循环结束后，最大的一位被交换到末尾，so下一轮就可以忽略最后的数，
	每一轮循环都比上一轮循环结束位置靠前一位。
	for(int i=0;i < ns.length - 1;i++){
		for(int j=0;j < ns.length-i-1;j++){
			if(ns[j] > ns[j+1]){
				int tmp = ns[j];
				ns[j] = ns[j+1];
				ns[j+1] = tmp;
			}
		}
    }这是冒泡排序的例子，降序只需要将if中的>换成<。
	还有二维数组：
		int[][] ns = {
            { 1, 2, 3, 4 },
            { 5, 6, 7, 8 },
            { 9, 10, 11, 12 }
        };酱紫的，二维数组要使用两个[][]，使用，隔开每个数组
		查看特定数组的某位数时ns[0][0]，意思是下标为0的数组中下标为0的数字。
		二维数组.length时显示的是二维数组的长度。
		ns[0].length查看下标为0数组的长度。
		Arrays.deepToString();能打印二位数组。
		还有一种三维数组，就是二维数组的数组。
		int[][][] ns = {
			{
				{1, 2, 3},
				{4, 5, 6},
				{7, 8, 9}
			},
			{
				{10, 11},
				{12, 13}
			},
			{
				{14, 15, 16},
				{17, 18}
			}
		};
	

命令行参数：
	程序入口时main方法，main方法可以接受一个命令行参数，它是String[]数组，此命令行由jvm接受用户输入传给main方法。


面向百度编程：
	class(类)
	instance(实例、类)
	method(方法)
	field(字段)
	面向过程编程：将模型分解成一步一步的过程，比如洗一个TODO任务：
					1.读取文件
					2.编写TODO
					3.保存文件
	面向对象编程：通过对象的方式，将现实世界映射到计算机模型的一种编程方式。
					基本概念：类、实例、方法。
					面向对象实现方式：继承、多态。
					java本身提供机制：package、classpath、jar。
					java标准库提供核心类：字符串、包装类型、javabean、枚举、常用工具类。
	
				类定义的是一种抽象的概念，如电脑是类，那么和电脑相关的实例都可放在其中。
				面向对象主要就是class(类)和instance(实例、对象)
				class是对象模板，定义如何创建实例，so，class本身就是一种数据类型。
				instance是对象实例，instance是根据class1创建的实例，可以创建多个instance，每个instance类型相同，但属性可能不同。
				
				将一组数据汇聚到对象上就是数据封装。
				Student s = new Student();
				创建了一个实例，通过变量s指向它，Studnet s是创建student的变量s，new Student()是创建实例。
				有了这个实例就能通过变量操作实例，s.字段。来使用studnet中封装的字段。
				如果实例类型一样，变量名不一样那么在调用字段的时候在内存中有独立的空间，互不干扰。
				指向instance的变量都是引用变量。
	方法：一个class可以含多个field，如果field使用public修饰暴露给外部会破坏封装性。
			可以使用private进行修饰拒绝外部访问，private是私密的，public是公用的。
			使用private的话，可用get、set方法让外部获取字段，外部用过调用get方法获取字段，set方法修改字段。
			也可以在set中加上判断，对输入值进行判断是否符合条件使输入值更加严谨。
		定义方法语句：
			修饰符 方法返回类型 方法名(方法参数列表) {
				若干方法语句;
				return 方法返回值;
			}	没有特定情况下可省略return。
			可以在其中的方法封装一个类的对外接口，调用方不需要也不用关心实例的方法中做了什么操作。
			
		在方法中可使用一个隐含变量this，它始终指向当前实例，so，通过this.field就能访问当前所在实例的字段。
		若没有命名冲突就可省略this，如歌有局部变量和字段冲突，那么局部变量优先级更高，必须加上this。
		
		方法参数：
			方法可以报包含多个参数，方法参数用于接收传递给方法的变量值，调用方法时，必须严格按照参数设定的定义传递。
		
		可变参数：
			相当于数组类型public void setNames(String... names) ，那么调用的时候就可以写成，
			g.setNames("Xiao Ming", "Xiao Hong", "Xiao Jun")。
			所以完全可以将可变参数改为数组类型。
			
		参数绑定：
			调用方将参数传递给实例方法时，调用传递值会按照参数位置进行绑定。
			基本参数类型传递，调用方法值的复制，双方各自的后续修改互不影响。
			但引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一对象，
			双方任意一方对此对象的修改都会影响对方(因为指向的同一对象)。
			
	构造方法：
		在创建实例的时候就将内部字段全部初始化为合适的值。
		创建类的时候，默认创建一个隐式的类的构造方法，默认的构造方法是无参的没有返回值的。
		如果自定义一个构造方法那么编译器就不再创建默认构造方法，这个时候我们就要自己创建无参构造。
		因为如果你自定义有参构造，那么实例化对象的时候构造方法中没有参数就会报错。
		没有在构造方法中初始化字段时，应用类型字段默认null，int默认0，布尔默认false。
		可以设置多个不同参数的构造方法来对应不同的参数需求。
		一个构造方法可调用另一个构造方法，使用this()；
	
	
	继承(extends)：
		java中只允许单继承，但是可以无限单继承，a继承b继承c继承d.....依次类推。、
		java中创建的类会默认继承object类，object是没有父类的。
		b类继承另a类的时候，b能使用a类的方法和属性，增加程序扩展性，使用extends实现继承。
		b继承a时，b就拥有了a的所有功能，也能为b添加独有的功能。
		术语中被继承的类被称为：
			超类(super class)
			父类(parent class)
			基类(base class)
		继承的类又称为：
			子类(subclass)
			扩展类(extended class)
		但是子类中不能有和符类相同的字段。
		继承的特点是子类无法访问符类的private字段或private的方法。这样的话继承的作用就被削弱了。
		这样的话，就需要将private改为protected，被protected修饰的字段或方法可以被子类访问。
		
		如果说this表示本类的话，那么super就是表示父类。类加载时会先加载构造方法，super()表示父类构造方法。
		使用父类字段时super.，而且如果有父类的话会先加载父类的信息再加载子类的。
		
		向上转型(upcasting)：子类类型安全转为父类类型称为向上转型,向上转型时将子类类型安全地变为更加抽象的父类。
							子类 子 = new 父类();	向上转型
		向下转型(downcasting)：将父类类型强制转换为子类类型，为避免出错，java提供instanceof操作符。
							可以判断变量所指向的实例是否是指定类型或此类型的子类，如果引用变量为null，
							那么对让你和instanceof的判断都为false。
							父类 父 = new 子类();  or  父类 父 = (父) new 子类();
						从java14后判断instanceof后可直接转型为指定变量，避免再次强制转换。
	继承and组合(is and has):				
		不能继承没有is关系的类，但是可以使用组合，就是a(子)可以持有一个b的实例。
		组合是has的关系。
		如果父类不想子类对父类某些方法或字段进行重写，使用final进行修饰，被final修饰的是常量并且不能修改的。
		如果一个类不想被继承也可使用final进行修饰，被final修饰的不能被继承。
			final修饰符有多种作用：

			final修饰的方法可以阻止被覆写；

			final修饰的class可以阻止被继承；

			final修饰的field必须在创建对象时初始化，随后不可修改。
		
	重载(Overload)：
		一个类中一系列方法功能相同，参数不同，就可以及那个这组方法编程同名方法，即重载。
		方法名相同，参数不同，是为重载(Overload)。重载返回值通常相同。
		(个人感觉重载和创建多个构造方法差不多)
	重写(Override)：子类定义一个和父类方法名一样的方法，是重写(Override)。
		重写的话方法名、参数、返回值相同。
		
	多态：		
		多态指的是针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。
		多态特性是运行期才能动态决定调用的子类方法，针对某个类型调用某个方法，执行的实际方法可能是某个子类的重写方法。
		多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。
		Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；
		
	抽象类：
		父类方法本身不需要实现任何功能，只是为了定义方法签名，让子类进行实现，这就是抽象方法。
		抽象方法使用abstract进行修饰，类名也用abstract进行修饰。
		抽象方法本身的作用是定义一个规范，子类进行方法重写。
		子类继承抽象类，必须重写抽象类方法否则子类还是抽象类。
		抽象方法也使得程序扩展性更高，耦合性降低。
	
	面向抽象编程：
		面向抽象的本质是抽象类只定义规范。
		不需要子类就能实现业务逻辑。
		具体业务逻辑由不同子类进行实现，调用者不必关心是谁实现。
	
	接口(interface)：
		抽象类的本质是定义规范，保证所有子类都有相同的接口实现，从而体现多态。
		接口和抽象类的区别是：
			接口所有方法必须都是抽象方法，实现接口implements关键字。
			抽象类可以有抽象方法和普通方法，继承类extends关键字。
		接口中只能有抽象方法，只能！！！
		
		java只能继承一个类但是可以实现无数个接口。
		
		抽象类和接口的对比如下：
						abstract class			interface
			继承		只能extends一个class	可以implements多个interface
			字段		可以定义实例字段		不能定义实例字段
			抽象方法	可以定义抽象方法		可以定义抽象方法
			非抽象方法	可以定义非抽象方法		可以定义default方法
												default是默认方法将public改为default。
			
	术语：
		接口分java和编程：
			java接口是指interface中全是抽象方法的定义。
			编程接口是指接口规范，方法签名、数据格式、网络协议等。
	
	静态字段静态方法：
		static修饰字段或方法是为静态，静态字段只有一个共享空间，所有实例都会共享此字段。
									  普通字段都会有独立的空间，每个实例的同名字段互不影响。
		
		普通实例方法需要通过实例变量，调用静态方法则不需要，通过类名即可：类名.方法名。
		因为静态方法属于class，so静态方法内部无法访问this变量，也无法访问实例字段只能访问静态字段。
		静态方法常用于工具类：
			Arrays.sort();
			Math.random();
			也用于辅助类，如main();
		interface因为是抽象类不能定义实例字段，但可以有静态字段而且必须为final类型。
		
	包：
		jvm执行的时候，只看完整类名，so只要报名不同，类就不同。
		包作用域：
			位于同一包内，不用public、protected、private的字段和方法就是包作用域。
		import：在使用其他class时需要导入包路径，但是创建实例的时候大部分都已经自动生成了。
			·	如果import com.* 就是将这个包下所有class都导入进来。
		
	作用域：
		第一要点是，代码从上到下执行，第一行无法访问第二行的变量。
		不能直接访问不同类的变量等等。
	
	模块：
		.class是jvm看到最小可执行文件，大型程序需要很多class，不便管理，所以jar文件就是class的容器。
		java9之前开发程序时除了自己的app.jar还需要一堆第三方jar包。
		jvm自带的标准库rt.jar不能写到classpath中不然会干扰jvm正常运行，漏写了某个运行用到的jar，
		那么运行时可能抛出ClassNotFoundException，jar只是存放class的容器，并不关心class之间的依赖。
		java9开始引入模块，为了解决依赖的问题，如果a.jar必须依赖b.jar才能运行，应该给a.jar加点说明，让他
		再编译和运行的时候自动定位到b.jar,这种依赖关系的class容器就是模块。
		
		从java9开始java库将rt.jar拆分成几十个模块，以.jmod扩展名标识，在$JAVA_HOME/jmods目录下。
			每个.jmod都是一个模块，模块名就是文件名。如java.base就是java.base.jmod，模块之间的
			关系已经写到模块内的module-info.class文件，所有模块之间莫简介依赖java.base,但是它不
			依赖任何模块，可将它看作成根模块。
		将一堆class封装成jar需要打包，将class封装成模块不但要打包号要写入依赖关系。
		
		创建模块：
			如在src下创建module-info.java文件，这是模块描述文件
			运行java需要jar，jdk提供了jlink命令，只使用程序需要的jar：
				$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.w件是b明确导出可访问的包。
	
	orld --output jre/
			权限访问：
				class访问权限只在一个模块内有效，模块之间，a要访问b的某个class，必要条件是b明确的到处可访问的包。
				只有声明导出的包外部代码才允许访问。
				如想访问com.itranswarp.sample.Greeting必须导出(exports)exports com.itranswarp.sample;



Java核心类：
	字符串

	StringBuilder

	StringJoiner

	包装类型

	JavaBean

	枚举

	常用工具类
	
	字符串和编码：
		
		String：是引用类，本身也是class。编译器对其有特殊处理可用"..."表示一个字符串。
				在其内部是通过char[]数组显示的如下：
				String s = new String(new char[]{'h','e','l','l','o'});
				字符串最重要的特点就是字符串不变，是通过内部的private final char[]以及没有任何修改char[]方法实现的。
			比较：==一般表示数值，字符串比较必须使用equals()，忽略大小写使用equalsIgnoreCase()方法。
				
			提取、搜索子串：
				搜索："字符串".indexOf("串");	显示串的下标
				      "字符串串".lastIndexOf("串");		显示最后一个串的下标
					  "字符串".startsWith("字符");		判断是否从字符开始 返回布尔
					  "字符串".endWith("符串");			判断时候以符串结尾 返回布尔
					  
				提取："字符串".substring(下标); 提取指定下标及以后的字符。
					  "字符串".substring(1,2);  只提取1，2下标的字符。
	
			去除首位空白字符：
				使用trim()一处字符串首尾空字符,如:\t, \r, \n;
				trim()并没有改变字符串内容,二十返回一个新字符串。
				strip()也可以移除首位空字符,但是中文空格的\u3000也会被移除。
			判断是否为空：
				"".isEmpty();		空字符串返回true,否则为false如:"  "
				" \n".isBlank();	含空白字符串返回true否则false如:"hello"
			替换字符串：
				变量名.replace('e','a');		将变量中的所有e改为a
				正则表达式替换：
					String s = "A,,B;C ,D";
					s.replaceAll("[\\,\\;\\s]+", ","); // "A,B,C,D" 将匹配的子串统一替换为，。
			分割字符串：
				split()方法，传入正则表达式，如下：
					String s = "A,B,C,D";
					String[] ss = s.split("\\,"); // {"A", "B", "C", "D"}
			拼接字符串：
				join()静态方法进行拼接，如下：
					String[] arr = {"A", "B", "C"};
					String s = String.join("***", arr); // "A***B***C"

			格式化字符串：
				formatted()和format静态方法传入其他参数替换占位符生成新的字符串：
					String s = "Hi %s, your score is %d!";
					System.out.println(s.formatted("Alice", 80));
					System.out.println(String.format("Hi %s, your score is %.2f!", "Bob", 59.5));
				后面有几个占位符就传几个参数，参数类型要和占位符一致，如果不确定的话使用%s因为其可以显示任何数据类型。
					%s：显示字符串；
					%d：显示整数；
					%x：显示十六进制整数；
					%f：显示浮点数。
			类型转换：
				将任意基本类型或引用类型转换为字符串，使用静态方法valueOf(),这是重载方法，编译器会根据适合的参数选择合适的方法。
					String.valueOf(123);
					String.valueOf(23.23);
					String.valueOf(true);
					String.valueOf(new Object());
				将字符串转为其他类型需要根据实际情况：
					int n = Integer.parseInt("123");	int类型
					boolean b1 = Boolean.parseBoolean("true");  Boolean类型
					将字符串对应的系统变量转换为integer，Integer是int的包装类
						Integer.getInteger("java.version"); // 版本号，11
					string和char互相转换：
						char[] cs = "Hello".toCharArray(); // String -> char[]
						String s = new String(cs); // char[] -> String
	
				因为String的不变特性，如果传入对象可能改变，就需要复制而不是直接引用。
		
		字符编码：
			简介在这里：https://www.liaoxuefeng.com/wiki/1252599548343744/1260469698963456
			因为不同编码的字符集是不一样的，所以统一发布了Unicode编码，将主要语言统一就不会发生冲突了。
			UTF-8是容错力强传输过程中某些字符出错不影响后续字符，因为是靠高字节位确定字符是几个字节的，常用于传输编码。
				byte[] b1 = "Hello".getBytes(); // 按系统默认编码转换，不推荐
				byte[] b2 = "Hello".getBytes("UTF-8"); // 按UTF-8编码转换
				byte[] b2 = "Hello".getBytes("GBK"); // 按GBK编码转换
				byte[] b3 = "Hello".getBytes(StandardCharsets.UTF_8); // 按UTF-8编码转换
				以上转换编码后就变成byte类型了。
				将byte转为String：
					byte[] b = ...
					String s1 = new String(b, "GBK"); // 按GBK转换
					String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换
			注：java的String和char在内存中总是以Unicode表示。
	
		小结：
			java字符串String是不可变对象。
			字符串操作不改变原字符内容，而是返回新字符。
			常用的字符串操作：提取字符串、查找、替换、大小写转换等。
			java使用unicode编码表示string和char。
			转换编码就是将string和byte[]转换，需要指定编码。
			转为byte[]优先考虑UTF-8编码。
	
	StringBuilder：
		可以使用+拼接字符串但是用for循环拼接字符串的话，每次循环创建新的字符串，抛弃旧的
		大部分都是临时对象，浪费内存影响GC(垃圾回收)效率。
		可使用StringBuilder，可变对象可以预分配缓冲区，所以新增字符串时不会创建新的临时对象。
		(当然拼接的时候还是要使用for，只是将string类型改为StringBuilder类型罢了)
		也可以进行链式操作：
			var sb = new StringBuilder(1024);
				sb.append("Mr ")
				  .append("Bob")
				  .append("!")
				  .insert(0, "Hello, ");
			System.out.println(sb.toString());
		StringBuffer是java早期的StringBuilder线程安全版本，通过同步保证多个线程操作StringBuffer也是安全的，
		但是同步会让执行速度下降。
		StringBuilder和StringBuffer接口完全相同，现在没有必要使用StringBuffer。
	
	StringJoiner:
		new StringJoiner(",");就是遍历数组的时候中间值与值之间加上，号，在使用stringjoiner的变量.add添加值即可。
		如果需要在值首位添加数据new StringJoiner(",", "头", "尾");	toString();是转为string类型。
		不指定首尾时可用静态方法String.join()更方便，因为在内部使用StringJoiner拼接字符。
		String.join(",", 数组名);	自动进行拼接
		
		
	包装类：
		java数据类型两种：基本：byte、short、int、long、boolean、float、double、char
						  引用：所有class和interface类型。
			引用类型能为null，基本类型不行。
			将基本类型视为引用的话，用到包装类。
			以下时基本类型的包装类，所有的包装类都是不变类：
				boolean			java.lang.Boolean
				byte			java.lang.Byte
				short			java.lang.Short
				int				java.lang.Integer
				long			java.lang.Long
				float			java.lang.Float
				double 			java.lang.Double
				char			java.lang.Character
			
			int和integer是可以互换的，编译器自动在int和integer之间转型。
			直接将int变为integer的复制方式，为自动装箱(Auto Boxing)，integer转为int的就是自动拆箱(Auto Unboxing)。
			自动拆装箱只发生在编译阶段，是为了少写代码。但会影响代码执行效率，编译后的class严格区分基本和引用的。
			自动拆箱时可能报NullPointerException。
			
			包装类是引用类型比如integer所以比较时用equals()。
			integer不可变类，如设置了值为1，第二次在设置变量b=2，那么值还是1。此例子不标准
			integer.valueOf()对于较小的数，始终返回相同的实例所以==恰好为true。
			integer==为true是因为，valueof返回之前，进行判断当前的值是否在-128-127之间，
			如果存在就直接返回引用不用重新开辟空间，
			如果不存在就创建一个新对象，
			利用缓存提高车光绪执行效率节约内存，但是还是尽量使用equals进行数值比较。
			可能integer.valueof可能始终返回同一个integer实例，所以：
				Integer n = new Integer(数值);
				Integer n = Integer.valueOf(数值);
				第二个好一点因为第一个总是创建新的实例，而且第二个将内部优化留给integer实现者去做。
			能创建新对象的静态方法称为静态工厂方法。
			Integer.valueOf就是，它尽可能返回缓存实例以节省内存。
			创建新对象时，优先选用静态工厂而不是new操作符。
		进制转换：
			Integer的静态方法：
				parseInt()将字符串解析成一个整数
			将整数格式化成指定进制的字符串：
				Integer.toString(100); 			"100",表示为10进制
				Integer.toString(100, 36); 		"2s",表示为36进制
				Integer.toHexString(100);  		"64",表示为16进制
				Integer.toOctalString(100); 	"144",表示为8进制
				Integer.toBinaryString(100);  	"1100100",表示为2进制
			顺带一提String好像在内存中只用二进制显示。
			程序的重要原则就是数据存储和显示分离。
			整数和浮点的包装类型都继承自number，so可直接通过包装类型获取各种基本类型。
	
	JavaBean(组件):	
		封装实体类为了让外部访问设置值，而创造的getset方法，这种方法称为javabean。
		boolean比较特殊读方法get变成is(具体是get还是is根据情况来)
		ecplise的getset的快捷键：Shift+Alt+S；或者 右键Source里面的getset。
	枚举JavaBean属性：
		例如：
		BeanInfo info = Introspector.getBeanInfo(Person.class);
        for (PropertyDescriptor pd : info.getPropertyDescriptors()) {
            System.out.println(pd.getName());
            System.out.println("  " + pd.getReadMethod());
            System.out.println("  " + pd.getWriteMethod());
        }
		使用Introspector枚举javabean的所有属性以及读写方法。
		class属性是从object继承的getClass()方法的。
	
	小结：JavaBean是一种命名规范的class，用getset定义熟悉。
		  使用Introspector.getBeanInfo()可以获取属性列表。
	
	
	
	
	