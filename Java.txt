Math.random()*10;	生成随机数*10，就是生成10以内不包括10，从0开始。


JDK文件解析：
	java安装bin目录下有很多可执行文件。
	java：是jvm，运行java程序就是启动jvm，然后可以让jvm执行指定的编译后的代码。
	javac：是java编译器，用于将java源码文件(.java后缀的文件)编译为java字节码文件(.class结尾)。
	jar：用于将一组.class文件打包成一个.jar文件，便于发布。
	javadoc：用于从java源码中自动提取注释并生成文档。
	jdb：java调试器，用于开发阶段的运行调试。

使用cmd运行java文件：
	创建一个文本文件写个类，类名和文件名一致，文件后缀改为java。
	先用javac将java文件编译成class字节码文件，然后使用java命令执行字节码文件
	Hello.java  >>compile>>  Hello.class  >>execute>>  Run on JVM
	source code	   (编译)	   byte code	 (执行)
	(源码文件)				  (字节码文件)
	
	可执行文件javac是编译器，可执行文件java是虚拟机。
	在保存java文件下打开cmd窗口，
	javac Hello.java	编译java文件，将java编译成class
	java  Hello.class	执行class文件
	以上步骤是必须的，但是在java11后加入了新的功能，可以运行单个文件源码了！
	也就是说可以直接运行java了，不需要使用javac编译成class文件了。
	但是在实际项目中很少有不依赖第三方库的java源码，大多情况下无法直接运行java源码文件，因为它需要以来其他的库。
	定义类的时候可以不写public也能正常编译，但是此类无法从命令行执行。
	java入口规定方法必须是静态的，方法名必须为main，括号内参数必须是String数组。

常用注释：
	单行注释：//
	多行注释：/*开头    */结尾
	特殊多行：/**   	*/结尾，中间每行以*开头
	
	
注：代码是按顺序执行的！！！	
	
java規定：
	类名以大写开头，方法名小写开头驼峰规则。
	public为访问修饰符，static是修饰符。
	方法上加上DOTO是等待后续修改或编写的方法。

基本数据类型：
	整数类型：byte、short、int、long
	浮点类型：float、double
	字符类型：char
	布尔类型：boolean
	计算机内存最小储存单元是字节(byte)，一个字节是一个8位二进制数，即8个bit(位)。
	它的二进制表示范围从00000000~11111111，换算成十进制0~255，换算成十六进制是00~ff。
	(身为数学渣子的我，从廖老师网站搬过来的)
	
	内存单元从0开始编号，称为内存地址，每个内存单元可看作是一间房间，内存地址是门牌号。
	一个字节是1byte，1024字节是1k，1024k是1m，1024m是1g，1024g是1t，一个拥有4t内存的计算机字节数量：
	4T = 4 x 1024G；
	   = 4 x 1024 x 1024M；
	   = 4 x 1024 x 1024 x 1024K；
	   = 4 x 1024 x 1024 x 1024 x 1024；
	   = 4398046511104；
	
	不同数据类型占用的字节也不一样：
	byte   	1	  整型
	short  	2	  整型
	char   	2	  字符型
	float  	4	  浮点
	int	   	4	  整型
	long   	8	  整型
	double 	8	  布尔
	因为不了解数学，一下只做了解：
		java定义的带符号的整型。最高位的bit表示符号位(0位正，1为负)
		浮点类型是小数，因为小数点可以向前或向后浮动，所以称为浮点，对于float浮点类型数值后需加上f，如1.33f。
		布尔只有true和false两个值，数值比较运算也可替代true和false如：false1=1>2	true=1<2。
		char只能保存一个字符使用单引号''。
		String字符串引用类型使用双引号""。
		引用类型类似C语言的指针，内部存储一个地址，指向某个对象在内存中的位置涉及类和数据库(数据库学的细碎后面再说)。
		常量需要在变量前加上final修饰符，常量名通常全部大写，常量值是不能被改变的，枚举enum相似，只是枚举定义的是类。
	
	var关键字：有事类型名过长可将变量的类型写为var：var s = new Shool(); 效果等同于  shool s = new shool();
			   因为编译器会根据赋值语句自动推断变量的类型。
	变量存在作用域即作用范围，在同一个或同一个中的{}花括号中生效，如果超出范围，编译器会报错。
	
	整数运算：
		java的整数遵循四则运算规则，可以任意嵌套小括号，括号内优先运算。
			
		自增减：++n的话表示先加1再引用n，n++则相反是先引用再加1。
		移位运算二进制中，左移是乘2，右移是除2。
		位运算：
			&：相同为1，不同为0。
			|：任意为1，结果为1。
			~：0，1互换，输入0时结果为1，反之亦然。
			^：两个数值不同为1，否则为0。
		运算符优先级：
					()
					! ~ ++ --
					* / %
					+ -
					<< >> >>>
					&
					|
					+= -= *= /=
		
		注意++写在前面和后面计算结果是不同的，++n表示先加1再引用n，n++表示先引用n再加1。
		不建议把++运算混入到常规运算中，容易自己把自己搞懵了。(搬运廖老师的原话，谁做项目写++n，n++的钻简直牛角尖，虽然是因为我不会)。
		自动类型转换发生在字节低转为字节高。
		强制类型转换字节高转为字节低，但是字节高转为字节低时会损失精度，导致结果不准确。
	浮点数运算：
		浮点数只能做加减乘除运算，不能做位运算和移位运算。
		浮点数虽然范围大但是常常无法精准表示。
		0.1在计算机中无法精确表示，因为十进制0.1转成二进制时无限循环小数。
		如果小数强转为整数类型的话，小数.后的值会被舍弃如，12.3和12.7皆为12。
		整数和浮点进行运算的时候整数自动转为浮点类型。
	布尔运算：
		只有true和false	；
			比较运算符：>，>=，<，<=，==，!=
			与运算 &&
			或运算 ||
			非运算 !
		关系运算符的优先级从高到低依次是：
			!
			>，>=，<，<=
			==，!=
			&&
			||
		布尔里有一种短路运算：
			x1 && x1 如果x1为false时x2不再进行运算，第一个值为false时不再进行运算直接返回false。
			如果x1为true时，第二个值错误不能进行运算时，会报错，这样来说短路也相当于是一种保护机制。
		三元运算符：
			表达式：成功？失败
			意思是如果a>b的话，就显示：后的语句，如果a<b的话就显示？后的语句。
	字符和字符串：
		字符时基本数据类型，是charrcter的缩写，保存一个unicode字符。
		查看字符在unicode中的编码只需要将char赋值给int即可。
		字符串常见的转义字符：
			\" 表示字符"
			\' 表示字符'
			\\ 表示字符\
			\n 表示换行符
			\r 表示回车符
			\t 表示Tab
			\u#### 表示一个Unicode编码的字符
			可以使用+将多个""进行连接效果和一个""一样
			如果使用+连接字符串和其他数据类型会将其他数据类型自动转为字符串再进行连接。
		从java13开始使用"""...."""表示多行字符串和/*...*/效果差不多。
		而且字符串是不可变的，变的是指向：
			如果创建了两个s字符串
				String s = "aa";
				String s = "bb";
				会在内存中创建两个变量aa和bb，s只是一个指针的效果，s="aa";时候虚拟机创建了aa字符串，
				然后用变量s指向它，第二次s="bb";时虚拟机创建bb并且s指向它。
				当然如果a="aa";已经创建aa变量了，b="aa";时b也只是去内存中指定了aa而已，也就是说aa在内存中只创建了一次。
			null和""是有区别的，null是没有值，"是为空的有效字符串。
	数组：
		数组可以是值类型或引用类型，但是数组本身是引用类型。
		多个相同的数据类型可以使用数组进行保存。
		int [] name = new int[2]; 第二个[]中的数字为数组的个数，数组下标为0,并且规定几个必须创建几个。
		name[0] = 1;
		name[1] = 2;
		name.length使用此语法获取数组大小。
		name[1]查看下标为1的数据，输入几查看几。
		int [] name = new int [] {1,2,3,4}; 使用此方式不用指定数组大小，输入保存的数据编译器自动推算数组大小。
		int [] name = {1,2,3,4}; 这是最简洁的创建数组方式。
		
流程控制：
	System.out表示输出流	System.in表示输入流
	语句从上到下按顺序执行。
	输出语句：System.out.print();	输出后不换行。
			  System.out.println(); 输出后换行。
			  ecplise中输入sout和sys使用alt+/快捷键快速生成。
			  占位符	说明
				%d		格式化输出整数
				%x		格式化输出十六进制整数
				%f		格式化输出浮点数
				%e		格式化输出科学计数法表示的浮点数
				%s		格式化字符串
	输入：先创建Scanner对象。
		Scanner scanner = new Scanner(System.in);
		scanner.nextLine();		输入字符串
		scanner.nextInt();		输入整数
	
	switch语句：使用多重if判断的话，switch更加清晰。
		switch(){
		case 1:
			break;
		case 2:
			break;
		default:
		}
		如值=1就进入第一层，因为case具有穿透性，不写break的话，会将下一层也输出，如果下一层也没break，就滚雪球了。
		default是默认值，case的顺序不影响逻辑。
		switch条件值也可以是字符串或者枚举。
		从java12开始switch语句更加简洁化，使用模式匹配保证只有一条路径会被执行，并且不需要break。
		switch(标准值){
			case "条件值" -> 语句 ;
			case "条件值" -> 语句 ;
			case "条件值" -> {语句 };
			default ->	语句;
		}
		以上是java12后的语句，如果写逻辑判断等有多个语句的话可用{}进行扩盖，并且新语法使用->。
		可以将swithc的值作为变量进行设置int xx = switch(){}
		可以case"123","312"使用,设置多个条件。可以使用yield返回一个值作为返回值。
	while循环：根据条件做循环就按，条件满足时退出循环
		while(条件表达式){
			循环语句
			值++；
		}
		开始时先判断条件表达式，如果位true就运行，false就终止跳出while循环。
		while必须在最底层使用条件值++，否则无限循环
	do{
		语句;
		值++;
	}while(条件表达式);
	dowhile较while不同，
	while先判断再执行，dowhile先执行再判断。
	
	for循环：最便利的循环之一，在每次循环后更新计数器计数器通常为1不需要写n++。
		for(int i=0; i<=100; i++){
			i<=100是条件；
			i++;是自增；
			int i=0;声明一个计数器并指定默认值；
		}
		对计数器变量的修改尽量在for循环中。
	for each使用此循环遍历数组,也能遍历输出map，list等集合。
		int [] a={1,3,5,7,9};
		for(int b : a){
			 System.out.println(b);
		}
		
		for循环可以访问数组索引，for each直接迭代每个数组元素，无法获取索引。
		
		在while和for中都能使用break和comtinue语句(switch也能用)
		在循环中判断加上break，当数值到达xx时就break，
		注意break只挑出当前那层循环，如果有两层在最里层加上break，就是跳出里层循环，外层循环不会结束。
		comtinue提前结束本次循环，comtinue后的语句不执行，然后继续循环。
	
数组：Arrays.toString(数组名);快速打印数组内容
	  Arrays.sort(数组名);对数组进行排序，但实际上时修改了数组本身。
	冒泡排序的特点，每一轮循环结束后，最大的一位被交换到末尾，so下一轮就可以忽略最后的数，
	每一轮循环都比上一轮循环结束位置靠前一位。
	for(int i=0;i < ns.length - 1;i++){
		for(int j=0;j < ns.length-i-1;j++){
			if(ns[j] > ns[j+1]){
				int tmp = ns[j];
				ns[j] = ns[j+1];
				ns[j+1] = tmp;
			}
		}
    }这是冒泡排序的例子，降序只需要将if中的>换成<。
	还有二维数组：
		int[][] ns = {
            { 1, 2, 3, 4 },
            { 5, 6, 7, 8 },
            { 9, 10, 11, 12 }
        };酱紫的，二维数组要使用两个[][]，使用，隔开每个数组
		查看特定数组的某位数时ns[0][0]，意思是下标为0的数组中下标为0的数字。
		二维数组.length时显示的是二维数组的长度。
		ns[0].length查看下标为0数组的长度。
		Arrays.deepToString();能打印二位数组。
		还有一种三维数组，就是二维数组的数组。
		int[][][] ns = {
			{
				{1, 2, 3},
				{4, 5, 6},
				{7, 8, 9}
			},
			{
				{10, 11},
				{12, 13}
			},
			{
				{14, 15, 16},
				{17, 18}
			}
		};
	

命令行参数：
	程序入口时main方法，main方法可以接受一个命令行参数，它是String[]数组，此命令行由jvm接受用户输入传给main方法。


面向百度编程：
	class(类)
	instance(实例、类)
	method(方法)
	field(字段)
	面向过程编程：将模型分解成一步一步的过程，比如洗一个TODO任务：
					1.读取文件
					2.编写TODO
					3.保存文件
	面向对象编程：通过对象的方式，将现实世界映射到计算机模型的一种编程方式。
					基本概念：类、实例、方法。
					面向对象实现方式：继承、多态。
					java本身提供机制：package、classpath、jar。
					java标准库提供核心类：字符串、包装类型、javabean、枚举、常用工具类。
	
				类定义的是一种抽象的概念，如电脑是类，那么和电脑相关的实例都可放在其中。
				面向对象主要就是class(类)和instance(实例、对象)
				class是对象模板，定义如何创建实例，so，class本身就是一种数据类型。
				instance是对象实例，instance是根据class1创建的实例，可以创建多个instance，每个instance类型相同，但属性可能不同。
				
				将一组数据汇聚到对象上就是数据封装。
				Student s = new Student();
				创建了一个实例，通过变量s指向它，Studnet s是创建student的变量s，new Student()是创建实例。
				有了这个实例就能通过变量操作实例，s.字段。来使用studnet中封装的字段。
				如果实例类型一样，变量名不一样那么在调用字段的时候在内存中有独立的空间，互不干扰。
				指向instance的变量都是引用变量。
	方法：一个class可以含多个field，如果field使用public修饰暴露给外部会破坏封装性。
			可以使用private进行修饰拒绝外部访问，private是私密的，public是公用的。
			使用private的话，可用get、set方法让外部获取字段，外部用过调用get方法获取字段，set方法修改字段。
			也可以在set中加上判断，对输入值进行判断是否符合条件使输入值更加严谨。
		定义方法语句：
			修饰符 方法返回类型 方法名(方法参数列表) {
				若干方法语句;
				return 方法返回值;
			}	没有特定情况下可省略return。
			可以在其中的方法封装一个类的对外接口，调用方不需要也不用关心实例的方法中做了什么操作。
			
		在方法中可使用一个隐含变量this，它始终指向当前实例，so，通过this.field就能访问当前所在实例的字段。
		若没有命名冲突就可省略this，如歌有局部变量和字段冲突，那么局部变量优先级更高，必须加上this。
		
		方法参数：
			方法可以报包含多个参数，方法参数用于接收传递给方法的变量值，调用方法时，必须严格按照参数设定的定义传递。
		
		可变参数：
			相当于数组类型public void setNames(String... names) ，那么调用的时候就可以写成，
			g.setNames("Xiao Ming", "Xiao Hong", "Xiao Jun")。
			所以完全可以将可变参数改为数组类型。
			
		参数绑定：
			调用方将参数传递给实例方法时，调用传递值会按照参数位置进行绑定。
			基本参数类型传递，调用方法值的复制，双方各自的后续修改互不影响。
			但引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一对象，
			双方任意一方对此对象的修改都会影响对方(因为指向的同一对象)。
			
	构造方法：
		在创建实例的时候就将内部字段全部初始化为合适的值。
		创建类的时候，默认创建一个隐式的类的构造方法，默认的构造方法是无参的没有返回值的。
		如果自定义一个构造方法那么编译器就不再创建默认构造方法，这个时候我们就要自己创建无参构造。
		因为如果你自定义有参构造，那么实例化对象的时候构造方法中没有参数就会报错。
		没有在构造方法中初始化字段时，应用类型字段默认null，int默认0，布尔默认false。
		可以设置多个不同参数的构造方法来对应不同的参数需求。
		一个构造方法可调用另一个构造方法，使用this()；
	
	
	继承(extends)：
		java中只允许单继承，但是可以无限单继承，a继承b继承c继承d.....依次类推。、
		java中创建的类会默认继承object类，object是没有父类的。
		b类继承另a类的时候，b能使用a类的方法和属性，增加程序扩展性，使用extends实现继承。
		b继承a时，b就拥有了a的所有功能，也能为b添加独有的功能。
		术语中被继承的类被称为：
			超类(super class)
			父类(parent class)
			基类(base class)
		继承的类又称为：
			子类(subclass)
			扩展类(extended class)
		但是子类中不能有和符类相同的字段。
		继承的特点是子类无法访问符类的private字段或private的方法。这样的话继承的作用就被削弱了。
		这样的话，就需要将private改为protected，被protected修饰的字段或方法可以被子类访问。
		
		如果说this表示本类的话，那么super就是表示父类。类加载时会先加载构造方法，super()表示父类构造方法。
		使用父类字段时super.，而且如果有父类的话会先加载父类的信息再加载子类的。
		
		向上转型(upcasting)：子类类型安全转为父类类型称为向上转型,向上转型时将子类类型安全地变为更加抽象的父类。
							子类 子 = new 父类();	向上转型
		向下转型(downcasting)：将父类类型强制转换为子类类型，为避免出错，java提供instanceof操作符。
							可以判断变量所指向的实例是否是指定类型或此类型的子类，如果引用变量为null，
							那么对让你和instanceof的判断都为false。
							父类 父 = new 子类();  or  父类 父 = (父) new 子类();
						从java14后判断instanceof后可直接转型为指定变量，避免再次强制转换。
	继承and组合(is and has):				
		不能继承没有is关系的类，但是可以使用组合，就是a(子)可以持有一个b的实例。
		组合是has的关系。
		如果父类不想子类对父类某些方法或字段进行重写，使用final进行修饰，被final修饰的是常量并且不能修改的。
		如果一个类不想被继承也可使用final进行修饰，被final修饰的不能被继承。
			final修饰符有多种作用：

			final修饰的方法可以阻止被覆写；

			final修饰的class可以阻止被继承；

			final修饰的field必须在创建对象时初始化，随后不可修改。
		
	重载(Overload)：
		一个类中一系列方法功能相同，参数不同，就可以及那个这组方法编程同名方法，即重载。
		方法名相同，参数不同，是为重载(Overload)。重载返回值通常相同。
		(个人感觉重载和创建多个构造方法差不多)
	重写(Override)：子类定义一个和父类方法名一样的方法，是重写(Override)。
		重写的话方法名、参数、返回值相同。
		
	多态：		
		多态指的是针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。
		多态特性是运行期才能动态决定调用的子类方法，针对某个类型调用某个方法，执行的实际方法可能是某个子类的重写方法。
		多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。
		Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；
		
	抽象类：
		父类方法本身不需要实现任何功能，只是为了定义方法签名，让子类进行实现，这就是抽象方法。
		抽象方法使用abstract进行修饰，类名也用abstract进行修饰。
		抽象方法本身的作用是定义一个规范，子类进行方法重写。
		子类继承抽象类，必须重写抽象类方法否则子类还是抽象类。
		抽象方法也使得程序扩展性更高，耦合性降低。
	
	面向抽象编程：
		面向抽象的本质是抽象类只定义规范。
		不需要子类就能实现业务逻辑。
		具体业务逻辑由不同子类进行实现，调用者不必关心是谁实现。
	
	接口(interface)：
		抽象类的本质是定义规范，保证所有子类都有相同的接口实现，从而体现多态。
		接口和抽象类的区别是：
			接口所有方法必须都是抽象方法，实现接口implements关键字。
			抽象类可以有抽象方法和普通方法，继承类extends关键字。
		接口中只能有抽象方法，只能！！！
		
		java只能继承一个类但是可以实现无数个接口。
		
		抽象类和接口的对比如下：
						abstract class			interface
			继承		只能extends一个class	可以implements多个interface
			字段		可以定义实例字段		不能定义实例字段
			抽象方法	可以定义抽象方法		可以定义抽象方法
			非抽象方法	可以定义非抽象方法		可以定义default方法
			
	术语：
		接口分java和编程：
			java接口是指interface中全是抽象方法的定义。
			编程接口是指接口规范，方法签名、数据格式、网络协议等。
		
		
		
		
		
		
		
	